"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/history/page",{

/***/ "(app-pages-browser)/./src/utils/leaveUtils.ts":
/*!*********************************!*\
  !*** ./src/utils/leaveUtils.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FRENCH_HOLIDAYS_2024: function() { return /* binding */ FRENCH_HOLIDAYS_2024; },\n/* harmony export */   FRENCH_HOLIDAYS_2025: function() { return /* binding */ FRENCH_HOLIDAYS_2025; },\n/* harmony export */   LEAVE_TYPES: function() { return /* binding */ LEAVE_TYPES; },\n/* harmony export */   calculateAvailableCarryover: function() { return /* binding */ calculateAvailableCarryover; },\n/* harmony export */   calculateAvailableRTTForPeriod: function() { return /* binding */ calculateAvailableRTTForPeriod; },\n/* harmony export */   calculateCurrentAvailableRTT: function() { return /* binding */ calculateCurrentAvailableRTT; },\n/* harmony export */   calculateLeaveBalances: function() { return /* binding */ calculateLeaveBalances; },\n/* harmony export */   calculateLeaveStats: function() { return /* binding */ calculateLeaveStats; },\n/* harmony export */   calculateMonthlyLeaveSummarySeparated: function() { return /* binding */ calculateMonthlyLeaveSummarySeparated; },\n/* harmony export */   calculateWorkingDays: function() { return /* binding */ calculateWorkingDays; },\n/* harmony export */   canTakeRTTForMonth: function() { return /* binding */ canTakeRTTForMonth; },\n/* harmony export */   formatDate: function() { return /* binding */ formatDate; },\n/* harmony export */   frenchDateToISO: function() { return /* binding */ frenchDateToISO; },\n/* harmony export */   generateCalendarDays: function() { return /* binding */ generateCalendarDays; },\n/* harmony export */   generateCarryoverSummary: function() { return /* binding */ generateCarryoverSummary; },\n/* harmony export */   getHolidaysForYear: function() { return /* binding */ getHolidaysForYear; },\n/* harmony export */   getLeaveTypeColor: function() { return /* binding */ getLeaveTypeColor; },\n/* harmony export */   getLeaveTypeIcon: function() { return /* binding */ getLeaveTypeIcon; },\n/* harmony export */   getLeaveTypeLabel: function() { return /* binding */ getLeaveTypeLabel; },\n/* harmony export */   isHoliday: function() { return /* binding */ isHoliday; },\n/* harmony export */   isValidFrenchDate: function() { return /* binding */ isValidFrenchDate; },\n/* harmony export */   isoDateToFrench: function() { return /* binding */ isoDateToFrench; },\n/* harmony export */   validateLeavePeriod: function() { return /* binding */ validateLeavePeriod; }\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=addDays,format,isAfter,isBefore,isSameDay,isWeekend!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isAfter.js\");\n/* harmony import */ var _barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=addDays,format,isAfter,isBefore,isSameDay,isWeekend!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isWeekend.js\");\n/* harmony import */ var _barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=addDays,format,isAfter,isBefore,isSameDay,isWeekend!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/addDays.js\");\n/* harmony import */ var _barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=addDays,format,isAfter,isBefore,isSameDay,isWeekend!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isSameDay.js\");\n/* harmony import */ var _barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=addDays,format,isAfter,isBefore,isSameDay,isWeekend!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/format.js\");\n/* harmony import */ var _barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=addDays,format,isAfter,isBefore,isSameDay,isWeekend!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isBefore.js\");\n/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns/locale */ \"(app-pages-browser)/./node_modules/date-fns/locale/fr.js\");\n\n\n// Configuration des types de congés\nconst LEAVE_TYPES = {\n    cp: {\n        label: \"Cong\\xe9s Pay\\xe9s\",\n        color: \"leave-cp\",\n        icon: \"\\uD83C\\uDFD6️\"\n    },\n    rtt: {\n        label: \"RTT\",\n        color: \"leave-rtt\",\n        icon: \"\\uD83D\\uDCC5\"\n    },\n    cet: {\n        label: \"CET\",\n        color: \"leave-cet\",\n        icon: \"\\uD83C\\uDFE5\"\n    },\n    sick: {\n        label: \"Maladie\",\n        color: \"leave-sick\",\n        icon: \"\\uD83C\\uDFE5\"\n    }\n};\n// Jours fériés français 2024\nconst FRENCH_HOLIDAYS_2024 = [\n    {\n        id: \"1\",\n        date: \"2024-01-01\",\n        name: \"Jour de l'an\",\n        country: \"FR\"\n    },\n    {\n        id: \"2\",\n        date: \"2024-05-01\",\n        name: \"F\\xeate du travail\",\n        country: \"FR\"\n    },\n    {\n        id: \"3\",\n        date: \"2024-05-08\",\n        name: \"Victoire 1945\",\n        country: \"FR\"\n    },\n    {\n        id: \"4\",\n        date: \"2024-05-09\",\n        name: \"Ascension\",\n        country: \"FR\"\n    },\n    {\n        id: \"5\",\n        date: \"2024-05-20\",\n        name: \"Lundi de Pentec\\xf4te\",\n        country: \"FR\"\n    },\n    {\n        id: \"6\",\n        date: \"2024-07-14\",\n        name: \"F\\xeate nationale\",\n        country: \"FR\"\n    },\n    {\n        id: \"7\",\n        date: \"2024-08-15\",\n        name: \"Assomption\",\n        country: \"FR\"\n    },\n    {\n        id: \"8\",\n        date: \"2024-11-01\",\n        name: \"Toussaint\",\n        country: \"FR\"\n    },\n    {\n        id: \"9\",\n        date: \"2024-11-11\",\n        name: \"Armistice\",\n        country: \"FR\"\n    },\n    {\n        id: \"10\",\n        date: \"2024-12-25\",\n        name: \"No\\xebl\",\n        country: \"FR\"\n    }\n];\n// Jours fériés français 2025\nconst FRENCH_HOLIDAYS_2025 = [\n    {\n        id: \"1\",\n        date: \"2025-01-01\",\n        name: \"Jour de l'an\",\n        country: \"FR\"\n    },\n    {\n        id: \"2\",\n        date: \"2025-05-01\",\n        name: \"F\\xeate du travail\",\n        country: \"FR\"\n    },\n    {\n        id: \"3\",\n        date: \"2025-05-08\",\n        name: \"Victoire 1945\",\n        country: \"FR\"\n    },\n    {\n        id: \"4\",\n        date: \"2025-05-29\",\n        name: \"Ascension\",\n        country: \"FR\"\n    },\n    {\n        id: \"5\",\n        date: \"2025-06-09\",\n        name: \"Lundi de Pentec\\xf4te\",\n        country: \"FR\"\n    },\n    {\n        id: \"6\",\n        date: \"2025-07-14\",\n        name: \"F\\xeate nationale\",\n        country: \"FR\"\n    },\n    {\n        id: \"7\",\n        date: \"2025-08-15\",\n        name: \"Assomption\",\n        country: \"FR\"\n    },\n    {\n        id: \"8\",\n        date: \"2025-11-01\",\n        name: \"Toussaint\",\n        country: \"FR\"\n    },\n    {\n        id: \"9\",\n        date: \"2025-11-11\",\n        name: \"Armistice\",\n        country: \"FR\"\n    },\n    {\n        id: \"10\",\n        date: \"2025-12-25\",\n        name: \"No\\xebl\",\n        country: \"FR\"\n    }\n];\n/**\n * Calcule le nombre de jours ouvrés entre deux dates\n */ function calculateWorkingDays(startDate, endDate) {\n    let holidays = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], isHalfDay = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, halfDayType = arguments.length > 4 ? arguments[4] : void 0;\n    // Parse dates safely using new Date() instead of parseISO\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    // Validate dates\n    if (isNaN(start.getTime()) || isNaN(end.getTime())) {\n        console.error(\"Invalid date input:\", {\n            startDate,\n            endDate\n        });\n        return 0;\n    }\n    let workingDays = 0;\n    let currentDate = start;\n    while(!(0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__.isAfter)(currentDate, end)){\n        if (!(0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_1__.isWeekend)(currentDate) && !isHoliday(currentDate, holidays)) {\n            workingDays++;\n        }\n        currentDate = (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_2__.addDays)(currentDate, 1);\n    }\n    // Si c'est un demi-jour, ajuster le calcul\n    if (isHalfDay && workingDays > 0) {\n        // Si c'est le même jour (début = fin), c'est 0.5 jour\n        if ((0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__.isSameDay)(start, end)) {\n            workingDays = 0.5;\n        } else {\n        // Pour les périodes de plusieurs jours, on peut ajuster selon le type de demi-jour\n        // Par défaut, on garde le calcul normal car les demi-jours sont généralement\n        // appliqués au premier ou dernier jour selon le contexte\n        }\n    }\n    return workingDays;\n}\n/**\n * Vérifie si une date est un jour férié\n */ function isHoliday(date, holidays) {\n    return holidays.some((holiday)=>{\n        const holidayDate = new Date(holiday.date);\n        // Comparer les dates en format YYYY-MM-DD pour éviter les problèmes de timezone\n        const dateStr = date.toISOString().split(\"T\")[0];\n        const holidayStr = holidayDate.toISOString().split(\"T\")[0];\n        return dateStr === holidayStr;\n    });\n}\n/**\n * Obtient les jours fériés pour une année donnée\n */ function getHolidaysForYear(year) {\n    if (year === 2024) return FRENCH_HOLIDAYS_2024;\n    if (year === 2025) return FRENCH_HOLIDAYS_2025;\n    // Pour les autres années, on peut étendre ou utiliser une API\n    return [];\n}\n/**\n * Calcule le solde de congés pour chaque type en incluant les reliquats\n */ function calculateLeaveBalances(leaves, quotas) {\n    let carryovers = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], year = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new Date().getFullYear();\n    const balances = [];\n    quotas.forEach((quota)=>{\n        const yearLeaves = leaves.filter((leave)=>leave.type === quota.type && new Date(leave.startDate).getFullYear() === year);\n        const used = yearLeaves.reduce((total, leave)=>total + leave.workingDays, 0);\n        // Calculer les reliquats pour ce type de congé\n        const carryoverDays = carryovers.filter((carryover)=>carryover.type === quota.type).reduce((total, carryover)=>total + carryover.days, 0);\n        // Le total inclut le quota annuel + les reliquats\n        const totalWithCarryover = quota.yearlyQuota + carryoverDays;\n        const remaining = Math.max(0, totalWithCarryover - used);\n        balances.push({\n            type: quota.type,\n            total: totalWithCarryover,\n            used,\n            remaining,\n            carryover: carryoverDays\n        });\n    });\n    return balances;\n}\n/**\n * Calcule les reliquats disponibles pour une année donnée\n */ function calculateAvailableCarryover(carryovers) {\n    let year = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Date().getFullYear();\n    const available = {\n        cp: 0,\n        rtt: 0,\n        cet: 0,\n        sick: 0\n    };\n    carryovers.forEach((carryover)=>{\n        available[carryover.type] += carryover.days;\n    });\n    return available;\n}\n/**\n * Génère un résumé des reliquats par année\n */ function generateCarryoverSummary(carryovers) {\n    const byYear = {};\n    const byType = {\n        cp: [],\n        rtt: [],\n        cet: [],\n        sick: []\n    };\n    const totalByType = {\n        cp: 0,\n        rtt: 0,\n        cet: 0,\n        sick: 0\n    };\n    carryovers.forEach((carryover)=>{\n        // Par année\n        if (!byYear[carryover.year]) {\n            byYear[carryover.year] = [];\n        }\n        byYear[carryover.year].push(carryover);\n        // Par type\n        byType[carryover.type].push(carryover);\n        totalByType[carryover.type] += carryover.days;\n    });\n    return {\n        byYear,\n        byType,\n        totalByType\n    };\n}\n/**\n * Valide si les RTT peuvent être pris pour un mois donné\n * Les RTT s'accumulent à la fin du mois, donc on ne peut les prendre\n * que si le mois correspondant est passé\n */ function canTakeRTTForMonth(targetMonth, targetYear) {\n    let currentDate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Date();\n    const currentMonth = currentDate.getMonth() + 1; // 1-12\n    const currentYear = currentDate.getFullYear();\n    // Si on est dans une année future, on ne peut pas encore prendre les RTT\n    if (targetYear > currentYear) {\n        return {\n            canTake: false,\n            reason: \"Les RTT de \".concat(targetYear, \" ne sont pas encore disponibles\"),\n            availableDays: 0\n        };\n    }\n    // Si on est dans une année passée, on peut prendre les RTT\n    if (targetYear < currentYear) {\n        return {\n            canTake: true,\n            availableDays: 2 // 2 RTT par mois\n        };\n    }\n    // Même année : vérifier si le mois est passé\n    if (targetMonth < currentMonth) {\n        return {\n            canTake: true,\n            availableDays: 2\n        };\n    } else if (targetMonth === currentMonth) {\n        // Pour le mois en cours, on peut prendre les RTT dès le début du mois\n        return {\n            canTake: true,\n            availableDays: 2\n        };\n    } else {\n        // Mois futur - possible en prévision\n        return {\n            canTake: true,\n            availableDays: 2,\n            reason: \"RTT disponible en pr\\xe9vision pour \".concat(targetYear)\n        };\n    }\n}\n/**\n * Calcule le nombre total de RTT disponibles pour une période donnée\n */ function calculateAvailableRTTForPeriod(startDate, endDate) {\n    let currentDate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Date();\n    const details = [];\n    let totalAvailable = 0;\n    const current = new Date(startDate);\n    while(current <= endDate){\n        const month = current.getMonth() + 1;\n        const year = current.getFullYear();\n        const validation = canTakeRTTForMonth(month, year, currentDate);\n        details.push({\n            month,\n            year,\n            available: validation.availableDays,\n            canTake: validation.canTake\n        });\n        // Pour les prévisions, on compte tous les mois (passés, présents et futurs)\n        totalAvailable += validation.availableDays;\n        // Passer au mois suivant\n        current.setMonth(current.getMonth() + 1);\n    }\n    return {\n        totalAvailable,\n        details\n    };\n}\n/**\n * Calcule le nombre total de RTT disponibles actuellement\n * (depuis le début de l'année jusqu'à maintenant)\n */ function calculateCurrentAvailableRTT() {\n    let currentDate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Date(), year = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : currentDate.getFullYear();\n    const details = [];\n    let totalAvailable = 0;\n    // Parcourir tous les mois de l'année (y compris les mois futurs en prévision)\n    for(let month = 1; month <= 12; month++){\n        const validation = canTakeRTTForMonth(month, year, currentDate);\n        details.push({\n            month,\n            available: validation.availableDays,\n            canTake: validation.canTake,\n            reason: validation.reason\n        });\n        // Pour les prévisions, on compte tous les mois (passés, présents et futurs)\n        totalAvailable += validation.availableDays;\n    }\n    return {\n        totalAvailable,\n        details\n    };\n}\n// Nouvelle fonction pour calculer les données séparées par type (réel vs prévision)\nfunction calculateMonthlyLeaveSummarySeparated(leaves, quotas) {\n    let carryovers = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], year = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new Date().getFullYear();\n    var _quotas_find, _quotas_find1, _quotas_find2, _carryovers_find, _carryovers_find1, _carryovers_find2;\n    const months = [];\n    const monthNames = [\n        \"Janvier\",\n        \"F\\xe9vrier\",\n        \"Mars\",\n        \"Avril\",\n        \"Mai\",\n        \"Juin\",\n        \"Juillet\",\n        \"Ao\\xfbt\",\n        \"Septembre\",\n        \"Octobre\",\n        \"Novembre\",\n        \"D\\xe9cembre\"\n    ];\n    const currentDate = new Date();\n    const currentMonth = currentDate.getMonth() + 1; // 1-12\n    const currentYear = currentDate.getFullYear();\n    // Récupérer les quotas\n    const rttQuota = ((_quotas_find = quotas.find((q)=>q.type === \"rtt\")) === null || _quotas_find === void 0 ? void 0 : _quotas_find.yearlyQuota) || 23;\n    const cpQuota = ((_quotas_find1 = quotas.find((q)=>q.type === \"cp\")) === null || _quotas_find1 === void 0 ? void 0 : _quotas_find1.yearlyQuota) || 25;\n    const cetQuota = ((_quotas_find2 = quotas.find((q)=>q.type === \"cet\")) === null || _quotas_find2 === void 0 ? void 0 : _quotas_find2.yearlyQuota) || 5;\n    const totalCPCETQuota = cpQuota + cetQuota;\n    // Récupérer les reliquats\n    const rttCarryover = ((_carryovers_find = carryovers.find((c)=>c.type === \"rtt\")) === null || _carryovers_find === void 0 ? void 0 : _carryovers_find.days) || 0;\n    const cpCarryover = ((_carryovers_find1 = carryovers.find((c)=>c.type === \"cp\")) === null || _carryovers_find1 === void 0 ? void 0 : _carryovers_find1.days) || 0;\n    const cetCarryover = ((_carryovers_find2 = carryovers.find((c)=>c.type === \"cet\")) === null || _carryovers_find2 === void 0 ? void 0 : _carryovers_find2.days) || 0;\n    const totalCPCETCarryover = cpCarryover + cetCarryover;\n    // Ajouter la ligne des reliquats au début\n    months.push({\n        month: 0,\n        monthName: \"Reliquats\",\n        rtt: {\n            real: {\n                taken: 0,\n                cumul: 0,\n                remaining: rttCarryover\n            },\n            forecast: {\n                taken: 0,\n                cumul: 0,\n                remaining: rttCarryover\n            }\n        },\n        cp: {\n            real: {\n                taken: 0,\n                cumul: 0,\n                remaining: totalCPCETCarryover\n            },\n            forecast: {\n                taken: 0,\n                cumul: 0,\n                remaining: totalCPCETCarryover\n            }\n        }\n    });\n    let rttCumulReal = 0;\n    let rttCumulForecast = 0;\n    let cpCumulReal = 0;\n    let cpCumulForecast = 0;\n    for(let month = 1; month <= 12; month++){\n        // Filtrer les congés pour ce mois et cette année\n        const monthLeaves = leaves.filter((leave)=>{\n            const leaveDate = new Date(leave.startDate);\n            return leaveDate.getFullYear() === year && leaveDate.getMonth() === month - 1;\n        });\n        // Séparer les congés réels et les prévisions\n        // Si le mois est passé, les prévisions deviennent réelles\n        const isMonthPassed = year < currentYear || year === currentYear && month < currentMonth;\n        const isCurrentMonth = year === currentYear && month === currentMonth;\n        // Congés réels : tous les congés non marqués comme prévision OU les prévisions des mois passés\n        const rttReal = monthLeaves.filter((leave)=>leave.type === \"rtt\" && (!leave.isForecast || isMonthPassed)).reduce((sum, leave)=>sum + leave.workingDays, 0);\n        const cpReal = monthLeaves.filter((leave)=>leave.type === \"cp\" && (!leave.isForecast || isMonthPassed)).reduce((sum, leave)=>sum + leave.workingDays, 0);\n        // Pour les prévisions, compter les congés marqués comme prévision des mois futurs\n        // ET les congés non marqués comme prévision des mois futurs (pour simulation)\n        const rttForecast = monthLeaves.filter((leave)=>leave.type === \"rtt\" && (leave.isForecast || !isMonthPassed && !isCurrentMonth)).reduce((sum, leave)=>sum + leave.workingDays, 0);\n        const cpForecast = monthLeaves.filter((leave)=>leave.type === \"cp\" && (leave.isForecast || !isMonthPassed && !isCurrentMonth)).reduce((sum, leave)=>sum + leave.workingDays, 0);\n        // Calculer les cumuls\n        rttCumulReal += rttReal;\n        rttCumulForecast += rttForecast;\n        cpCumulReal += cpReal;\n        cpCumulForecast += cpForecast;\n        // Calculer les soldes restants (cumuls inversés)\n        // Les reliquats sont déjà inclus dans les quotas totaux\n        const rttRemainingReal = Math.max(0, rttQuota + rttCarryover - rttCumulReal);\n        const rttRemainingForecast = Math.max(0, rttQuota + rttCarryover - rttCumulReal - rttCumulForecast);\n        const cpRemainingReal = Math.max(0, totalCPCETQuota + totalCPCETCarryover - cpCumulReal);\n        const cpRemainingForecast = Math.max(0, totalCPCETQuota + totalCPCETCarryover - cpCumulReal - cpCumulForecast);\n        months.push({\n            month,\n            monthName: monthNames[month - 1],\n            rtt: {\n                real: {\n                    taken: rttReal,\n                    cumul: rttCumulReal,\n                    remaining: rttRemainingReal\n                },\n                forecast: {\n                    taken: rttForecast,\n                    cumul: rttCumulForecast,\n                    remaining: rttRemainingForecast\n                }\n            },\n            cp: {\n                real: {\n                    taken: cpReal,\n                    cumul: cpCumulReal,\n                    remaining: cpRemainingReal\n                },\n                forecast: {\n                    taken: cpForecast,\n                    cumul: cpCumulForecast,\n                    remaining: cpRemainingForecast\n                }\n            }\n        });\n    }\n    return {\n        months,\n        yearlyTotals: {\n            rtt: {\n                real: rttCumulReal,\n                forecast: rttCumulForecast,\n                total: rttCumulReal + rttCumulForecast\n            },\n            cp: {\n                real: cpCumulReal,\n                forecast: cpCumulForecast,\n                total: cpCumulReal + cpCumulForecast\n            }\n        }\n    };\n}\n// Fonction utilitaire pour vérifier si deux congés correspondent à la même période\nfunction isSamePeriod(forecast, real) {\n    // Si c'est un seul jour, vérifier la date exacte\n    if (forecast.workingDays === 1 && real.workingDays === 1) {\n        return forecast.startDate === real.startDate;\n    }\n    // Si c'est une période, vérifier si les dates se chevauchent\n    const forecastStart = new Date(forecast.startDate);\n    const forecastEnd = new Date(forecast.endDate);\n    const realStart = new Date(real.startDate);\n    const realEnd = new Date(real.endDate);\n    // Vérifier si les périodes se chevauchent\n    return forecastStart <= realEnd && realStart <= forecastEnd;\n}\n/**\n * Génère les données du calendrier pour un mois donné\n */ function generateCalendarDays(year, month, leaves, holidays) {\n    const days = [];\n    const startDate = new Date(year, month - 1, 1);\n    const endDate = new Date(year, month, 0);\n    let currentDate = startDate;\n    while(currentDate <= endDate){\n        const dateStr = (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(currentDate, \"yyyy-MM-dd\");\n        const leave = leaves.find((l)=>{\n            const leaveStart = new Date(l.startDate);\n            const leaveEnd = new Date(l.endDate);\n            return (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__.isSameDay)(currentDate, leaveStart) || (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__.isSameDay)(currentDate, leaveEnd) || (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__.isAfter)(currentDate, leaveStart) && (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_5__.isBefore)(currentDate, leaveEnd);\n        });\n        const holiday = holidays.find((h)=>{\n            const holidayDate = new Date(h.date);\n            return (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__.isSameDay)(currentDate, holidayDate);\n        });\n        days.push({\n            date: dateStr,\n            isLeave: !!leave,\n            leaveType: leave === null || leave === void 0 ? void 0 : leave.type,\n            isWeekend: (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_1__.isWeekend)(currentDate),\n            isHoliday: !!holiday,\n            holidayName: holiday === null || holiday === void 0 ? void 0 : holiday.name\n        });\n        currentDate = (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_2__.addDays)(currentDate, 1);\n    }\n    return days;\n}\n/**\n * Formate une date pour l'affichage\n */ function formatDate(date) {\n    let formatStr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"dd/MM/yyyy\";\n    const dateObj = typeof date === \"string\" ? new Date(date) : date;\n    // Validate the date\n    if (isNaN(dateObj.getTime())) {\n        console.error(\"Invalid date for formatting:\", date);\n        return \"Date invalide\";\n    }\n    return (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(dateObj, formatStr, {\n        locale: date_fns_locale__WEBPACK_IMPORTED_MODULE_6__.fr\n    });\n}\n/**\n * Obtient le nom du type de congé\n */ function getLeaveTypeLabel(type) {\n    return LEAVE_TYPES[type].label;\n}\n/**\n * Obtient la couleur du type de congé\n */ function getLeaveTypeColor(type) {\n    return LEAVE_TYPES[type].color;\n}\n/**\n * Obtient l'icône du type de congé\n */ function getLeaveTypeIcon(type) {\n    return LEAVE_TYPES[type].icon;\n}\n/**\n * Valide une période de congés\n */ function validateLeavePeriod(startDate, endDate, existingLeaves, excludeId) {\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    if ((0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__.isAfter)(start, end)) {\n        return {\n            isValid: false,\n            error: \"La date de d\\xe9but doit \\xeatre ant\\xe9rieure \\xe0 la date de fin\"\n        };\n    }\n    // Vérifier les chevauchements avec les congés existants\n    const overlapping = existingLeaves.filter((leave)=>leave.id !== excludeId).some((leave)=>{\n        const leaveStart = new Date(leave.startDate);\n        const leaveEnd = new Date(leave.endDate);\n        return (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__.isAfter)(start, leaveStart) && (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_5__.isBefore)(start, leaveEnd) || (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__.isAfter)(end, leaveStart) && (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_5__.isBefore)(end, leaveEnd) || (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_5__.isBefore)(start, leaveStart) && (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__.isAfter)(end, leaveEnd) || (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__.isSameDay)(start, leaveStart) || (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__.isSameDay)(end, leaveEnd);\n    });\n    if (overlapping) {\n        return {\n            isValid: false,\n            error: \"Cette p\\xe9riode chevauche un cong\\xe9 existant\"\n        };\n    }\n    return {\n        isValid: true\n    };\n}\n/**\n * Calcule les statistiques des congés\n */ function calculateLeaveStats(leaves, year) {\n    const yearLeaves = leaves.filter((leave)=>new Date(leave.startDate).getFullYear() === year);\n    const totalDays = yearLeaves.reduce((total, leave)=>total + leave.workingDays, 0);\n    const byType = {\n        cp: 0,\n        rtt: 0,\n        cet: 0,\n        sick: 0\n    };\n    const byMonth = {};\n    yearLeaves.forEach((leave)=>{\n        byType[leave.type] += leave.workingDays;\n        const leaveStart = new Date(leave.startDate);\n        const month = (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(leaveStart, \"yyyy-MM\");\n        byMonth[month] = (byMonth[month] || 0) + leave.workingDays;\n    });\n    return {\n        totalDays,\n        byType,\n        byMonth\n    };\n}\n/**\n * Convertit une date du format français (DD/MM/YYYY) vers le format ISO (YYYY-MM-DD)\n */ function frenchDateToISO(frenchDate) {\n    if (!frenchDate || frenchDate.length !== 10) return \"\";\n    const parts = frenchDate.split(\"/\");\n    if (parts.length !== 3) return \"\";\n    const [day, month, year] = parts;\n    return \"\".concat(year, \"-\").concat(month.padStart(2, \"0\"), \"-\").concat(day.padStart(2, \"0\"));\n}\n/**\n * Convertit une date du format ISO (YYYY-MM-DD) vers le format français (DD/MM/YYYY)\n */ function isoDateToFrench(isoDate) {\n    if (!isoDate || isoDate.length !== 10) return \"\";\n    const parts = isoDate.split(\"-\");\n    if (parts.length !== 3) return \"\";\n    const [year, month, day] = parts;\n    return \"\".concat(day, \"/\").concat(month, \"/\").concat(year);\n}\n/**\n * Valide une date au format français (DD/MM/YYYY)\n */ function isValidFrenchDate(frenchDate) {\n    if (!frenchDate || frenchDate.length !== 10) return false;\n    const parts = frenchDate.split(\"/\");\n    if (parts.length !== 3) return false;\n    const [day, month, year] = parts;\n    const isoDate = \"\".concat(year, \"-\").concat(month.padStart(2, \"0\"), \"-\").concat(day.padStart(2, \"0\"));\n    const date = new Date(isoDate);\n    return !isNaN(date.getTime()) && date.getFullYear() >= 2020 && date.getFullYear() <= 2030;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9sZWF2ZVV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRjtBQUMvQztBQUdyQyxvQ0FBb0M7QUFDN0IsTUFBTU8sY0FBYztJQUN6QkMsSUFBSTtRQUFFQyxPQUFPO1FBQWdCQyxPQUFPO1FBQVlDLE1BQU07SUFBTTtJQUM1REMsS0FBSztRQUFFSCxPQUFPO1FBQU9DLE9BQU87UUFBYUMsTUFBTTtJQUFLO0lBQ3BERSxLQUFLO1FBQUVKLE9BQU87UUFBT0MsT0FBTztRQUFhQyxNQUFNO0lBQUs7SUFDcERHLE1BQU07UUFBRUwsT0FBTztRQUFXQyxPQUFPO1FBQWNDLE1BQU07SUFBSztBQUM1RCxFQUFXO0FBRVgsNkJBQTZCO0FBQ3RCLE1BQU1JLHVCQUF3QztJQUNuRDtRQUFFQyxJQUFJO1FBQUtDLE1BQU07UUFBY0MsTUFBTTtRQUFpQkMsU0FBUztJQUFLO0lBQ3BFO1FBQUVILElBQUk7UUFBS0MsTUFBTTtRQUFjQyxNQUFNO1FBQW1CQyxTQUFTO0lBQUs7SUFDdEU7UUFBRUgsSUFBSTtRQUFLQyxNQUFNO1FBQWNDLE1BQU07UUFBaUJDLFNBQVM7SUFBSztJQUNwRTtRQUFFSCxJQUFJO1FBQUtDLE1BQU07UUFBY0MsTUFBTTtRQUFhQyxTQUFTO0lBQUs7SUFDaEU7UUFBRUgsSUFBSTtRQUFLQyxNQUFNO1FBQWNDLE1BQU07UUFBc0JDLFNBQVM7SUFBSztJQUN6RTtRQUFFSCxJQUFJO1FBQUtDLE1BQU07UUFBY0MsTUFBTTtRQUFrQkMsU0FBUztJQUFLO0lBQ3JFO1FBQUVILElBQUk7UUFBS0MsTUFBTTtRQUFjQyxNQUFNO1FBQWNDLFNBQVM7SUFBSztJQUNqRTtRQUFFSCxJQUFJO1FBQUtDLE1BQU07UUFBY0MsTUFBTTtRQUFhQyxTQUFTO0lBQUs7SUFDaEU7UUFBRUgsSUFBSTtRQUFLQyxNQUFNO1FBQWNDLE1BQU07UUFBYUMsU0FBUztJQUFLO0lB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c0gsT0FBMUIxRSxNQUFNMkUsUUFBUSxDQUFDLEdBQUcsTUFBSyxLQUF3QixPQUFyQkQsSUFBSUMsUUFBUSxDQUFDLEdBQUc7QUFDOUQ7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDLGdCQUFnQkMsT0FBZTtJQUM3QyxJQUFJLENBQUNBLFdBQVdBLFFBQVFMLE1BQU0sS0FBSyxJQUFJLE9BQU87SUFFOUMsTUFBTUMsUUFBUUksUUFBUTVILEtBQUssQ0FBQztJQUM1QixJQUFJd0gsTUFBTUQsTUFBTSxLQUFLLEdBQUcsT0FBTztJQUUvQixNQUFNLENBQUNwSCxNQUFNNEMsT0FBTzBFLElBQUksR0FBR0Q7SUFDM0IsT0FBTyxHQUFVekUsT0FBUDBFLEtBQUksS0FBWXRILE9BQVQ0QyxPQUFNLEtBQVEsT0FBTDVDO0FBQzVCO0FBRUE7O0NBRUMsR0FDTSxTQUFTMEgsa0JBQWtCUCxVQUFrQjtJQUNsRCxJQUFJLENBQUNBLGNBQWNBLFdBQVdDLE1BQU0sS0FBSyxJQUFJLE9BQU87SUFFcEQsTUFBTUMsUUFBUUYsV0FBV3RILEtBQUssQ0FBQztJQUMvQixJQUFJd0gsTUFBTUQsTUFBTSxLQUFLLEdBQUcsT0FBTztJQUUvQixNQUFNLENBQUNFLEtBQUsxRSxPQUFPNUMsS0FBSyxHQUFHcUg7SUFDM0IsTUFBTUksVUFBVSxHQUFXN0UsT0FBUjVDLE1BQUssS0FBNkJzSCxPQUExQjFFLE1BQU0yRSxRQUFRLENBQUMsR0FBRyxNQUFLLEtBQXdCLE9BQXJCRCxJQUFJQyxRQUFRLENBQUMsR0FBRztJQUNyRSxNQUFNbkosT0FBTyxJQUFJVyxLQUFLMEk7SUFFdEIsT0FBTyxDQUFDeEksTUFBTWIsS0FBS2MsT0FBTyxPQUNuQmQsS0FBS2lDLFdBQVcsTUFBTSxRQUN0QmpDLEtBQUtpQyxXQUFXLE1BQU07QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2xlYXZlVXRpbHMudHM/YjdjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhZGREYXlzLCBmb3JtYXQsIGlzQWZ0ZXIsIGlzQmVmb3JlLCBpc1NhbWVEYXksIGlzV2Vla2VuZCB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCB7IGZyIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlJztcbmltcG9ydCB7IENhbGVuZGFyRGF5LCBDYXJyeW92ZXJMZWF2ZSwgTGVhdmVCYWxhbmNlLCBMZWF2ZUVudHJ5LCBMZWF2ZVR5cGUsIFB1YmxpY0hvbGlkYXkgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8vIENvbmZpZ3VyYXRpb24gZGVzIHR5cGVzIGRlIGNvbmfDqXNcbmV4cG9ydCBjb25zdCBMRUFWRV9UWVBFUyA9IHtcbiAgY3A6IHsgbGFiZWw6ICdDb25nw6lzIFBhecOpcycsIGNvbG9yOiAnbGVhdmUtY3AnLCBpY29uOiAn8J+Plu+4jycgfSxcbiAgcnR0OiB7IGxhYmVsOiAnUlRUJywgY29sb3I6ICdsZWF2ZS1ydHQnLCBpY29uOiAn8J+ThScgfSxcbiAgY2V0OiB7IGxhYmVsOiAnQ0VUJywgY29sb3I6ICdsZWF2ZS1jZXQnLCBpY29uOiAn8J+PpScgfSxcbiAgc2ljazogeyBsYWJlbDogJ01hbGFkaWUnLCBjb2xvcjogJ2xlYXZlLXNpY2snLCBpY29uOiAn8J+PpScgfSxcbn0gYXMgY29uc3Q7XG5cbi8vIEpvdXJzIGbDqXJpw6lzIGZyYW7Dp2FpcyAyMDI0XG5leHBvcnQgY29uc3QgRlJFTkNIX0hPTElEQVlTXzIwMjQ6IFB1YmxpY0hvbGlkYXlbXSA9IFtcbiAgeyBpZDogJzEnLCBkYXRlOiAnMjAyNC0wMS0wMScsIG5hbWU6ICdKb3VyIGRlIGxcXCdhbicsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzInLCBkYXRlOiAnMjAyNC0wNS0wMScsIG5hbWU6ICdGw6p0ZSBkdSB0cmF2YWlsJywgY291bnRyeTogJ0ZSJyB9LFxuICB7IGlkOiAnMycsIGRhdGU6ICcyMDI0LTA1LTA4JywgbmFtZTogJ1ZpY3RvaXJlIDE5NDUnLCBjb3VudHJ5OiAnRlInIH0sXG4gIHsgaWQ6ICc0JywgZGF0ZTogJzIwMjQtMDUtMDknLCBuYW1lOiAnQXNjZW5zaW9uJywgY291bnRyeTogJ0ZSJyB9LFxuICB7IGlkOiAnNScsIGRhdGU6ICcyMDI0LTA1LTIwJywgbmFtZTogJ0x1bmRpIGRlIFBlbnRlY8O0dGUnLCBjb3VudHJ5OiAnRlInIH0sXG4gIHsgaWQ6ICc2JywgZGF0ZTogJzIwMjQtMDctMTQnLCBuYW1lOiAnRsOqdGUgbmF0aW9uYWxlJywgY291bnRyeTogJ0ZSJyB9LFxuICB7IGlkOiAnNycsIGRhdGU6ICcyMDI0LTA4LTE1JywgbmFtZTogJ0Fzc29tcHRpb24nLCBjb3VudHJ5OiAnRlInIH0sXG4gIHsgaWQ6ICc4JywgZGF0ZTogJzIwMjQtMTEtMDEnLCBuYW1lOiAnVG91c3NhaW50JywgY291bnRyeTogJ0ZSJyB9LFxuICB7IGlkOiAnOScsIGRhdGU6ICcyMDI0LTExLTExJywgbmFtZTogJ0FybWlzdGljZScsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzEwJywgZGF0ZTogJzIwMjQtMTItMjUnLCBuYW1lOiAnTm/Dq2wnLCBjb3VudHJ5OiAnRlInIH0sXG5dO1xuXG4vLyBKb3VycyBmw6lyacOpcyBmcmFuw6dhaXMgMjAyNVxuZXhwb3J0IGNvbnN0IEZSRU5DSF9IT0xJREFZU18yMDI1OiBQdWJsaWNIb2xpZGF5W10gPSBbXG4gIHsgaWQ6ICcxJywgZGF0ZTogJzIwMjUtMDEtMDEnLCBuYW1lOiAnSm91ciBkZSBsXFwnYW4nLCBjb3VudHJ5OiAnRlInIH0sXG4gIHsgaWQ6ICcyJywgZGF0ZTogJzIwMjUtMDUtMDEnLCBuYW1lOiAnRsOqdGUgZHUgdHJhdmFpbCcsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzMnLCBkYXRlOiAnMjAyNS0wNS0wOCcsIG5hbWU6ICdWaWN0b2lyZSAxOTQ1JywgY291bnRyeTogJ0ZSJyB9LFxuICB7IGlkOiAnNCcsIGRhdGU6ICcyMDI1LTA1LTI5JywgbmFtZTogJ0FzY2Vuc2lvbicsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzUnLCBkYXRlOiAnMjAyNS0wNi0wOScsIG5hbWU6ICdMdW5kaSBkZSBQZW50ZWPDtHRlJywgY291bnRyeTogJ0ZSJyB9LFxuICB7IGlkOiAnNicsIGRhdGU6ICcyMDI1LTA3LTE0JywgbmFtZTogJ0bDqnRlIG5hdGlvbmFsZScsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzcnLCBkYXRlOiAnMjAyNS0wOC0xNScsIG5hbWU6ICdBc3NvbXB0aW9uJywgY291bnRyeTogJ0ZSJyB9LFxuICB7IGlkOiAnOCcsIGRhdGU6ICcyMDI1LTExLTAxJywgbmFtZTogJ1RvdXNzYWludCcsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzknLCBkYXRlOiAnMjAyNS0xMS0xMScsIG5hbWU6ICdBcm1pc3RpY2UnLCBjb3VudHJ5OiAnRlInIH0sXG4gIHsgaWQ6ICcxMCcsIGRhdGU6ICcyMDI1LTEyLTI1JywgbmFtZTogJ05vw6tsJywgY291bnRyeTogJ0ZSJyB9LFxuXTtcblxuLyoqXG4gKiBDYWxjdWxlIGxlIG5vbWJyZSBkZSBqb3VycyBvdXZyw6lzIGVudHJlIGRldXggZGF0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVdvcmtpbmdEYXlzKFxuICBzdGFydERhdGU6IHN0cmluZywgXG4gIGVuZERhdGU6IHN0cmluZywgXG4gIGhvbGlkYXlzOiBQdWJsaWNIb2xpZGF5W10gPSBbXSxcbiAgaXNIYWxmRGF5OiBib29sZWFuID0gZmFsc2UsXG4gIGhhbGZEYXlUeXBlPzogJ21vcm5pbmcnIHwgJ2FmdGVybm9vbidcbik6IG51bWJlciB7XG4gIC8vIFBhcnNlIGRhdGVzIHNhZmVseSB1c2luZyBuZXcgRGF0ZSgpIGluc3RlYWQgb2YgcGFyc2VJU09cbiAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZShzdGFydERhdGUpO1xuICBjb25zdCBlbmQgPSBuZXcgRGF0ZShlbmREYXRlKTtcbiAgXG4gIC8vIFZhbGlkYXRlIGRhdGVzXG4gIGlmIChpc05hTihzdGFydC5nZXRUaW1lKCkpIHx8IGlzTmFOKGVuZC5nZXRUaW1lKCkpKSB7XG4gICAgY29uc29sZS5lcnJvcignSW52YWxpZCBkYXRlIGlucHV0OicsIHsgc3RhcnREYXRlLCBlbmREYXRlIH0pO1xuICAgIHJldHVybiAwO1xuICB9XG4gIFxuICBsZXQgd29ya2luZ0RheXMgPSAwO1xuICBsZXQgY3VycmVudERhdGUgPSBzdGFydDtcblxuICB3aGlsZSAoIWlzQWZ0ZXIoY3VycmVudERhdGUsIGVuZCkpIHtcbiAgICBpZiAoIWlzV2Vla2VuZChjdXJyZW50RGF0ZSkgJiYgIWlzSG9saWRheShjdXJyZW50RGF0ZSwgaG9saWRheXMpKSB7XG4gICAgICB3b3JraW5nRGF5cysrO1xuICAgIH1cbiAgICBjdXJyZW50RGF0ZSA9IGFkZERheXMoY3VycmVudERhdGUsIDEpO1xuICB9XG5cbiAgLy8gU2kgYydlc3QgdW4gZGVtaS1qb3VyLCBhanVzdGVyIGxlIGNhbGN1bFxuICBpZiAoaXNIYWxmRGF5ICYmIHdvcmtpbmdEYXlzID4gMCkge1xuICAgIC8vIFNpIGMnZXN0IGxlIG3Dqm1lIGpvdXIgKGTDqWJ1dCA9IGZpbiksIGMnZXN0IDAuNSBqb3VyXG4gICAgaWYgKGlzU2FtZURheShzdGFydCwgZW5kKSkge1xuICAgICAgd29ya2luZ0RheXMgPSAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFBvdXIgbGVzIHDDqXJpb2RlcyBkZSBwbHVzaWV1cnMgam91cnMsIG9uIHBldXQgYWp1c3RlciBzZWxvbiBsZSB0eXBlIGRlIGRlbWktam91clxuICAgICAgLy8gUGFyIGTDqWZhdXQsIG9uIGdhcmRlIGxlIGNhbGN1bCBub3JtYWwgY2FyIGxlcyBkZW1pLWpvdXJzIHNvbnQgZ8OpbsOpcmFsZW1lbnRcbiAgICAgIC8vIGFwcGxpcXXDqXMgYXUgcHJlbWllciBvdSBkZXJuaWVyIGpvdXIgc2Vsb24gbGUgY29udGV4dGVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya2luZ0RheXM7XG59XG5cbi8qKlxuICogVsOpcmlmaWUgc2kgdW5lIGRhdGUgZXN0IHVuIGpvdXIgZsOpcmnDqVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIb2xpZGF5KGRhdGU6IERhdGUsIGhvbGlkYXlzOiBQdWJsaWNIb2xpZGF5W10pOiBib29sZWFuIHtcbiAgcmV0dXJuIGhvbGlkYXlzLnNvbWUoaG9saWRheSA9PiB7XG4gICAgY29uc3QgaG9saWRheURhdGUgPSBuZXcgRGF0ZShob2xpZGF5LmRhdGUpO1xuICAgIC8vIENvbXBhcmVyIGxlcyBkYXRlcyBlbiBmb3JtYXQgWVlZWS1NTS1ERCBwb3VyIMOpdml0ZXIgbGVzIHByb2Jsw6htZXMgZGUgdGltZXpvbmVcbiAgICBjb25zdCBkYXRlU3RyID0gZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gICAgY29uc3QgaG9saWRheVN0ciA9IGhvbGlkYXlEYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICByZXR1cm4gZGF0ZVN0ciA9PT0gaG9saWRheVN0cjtcbiAgfSk7XG59XG5cbi8qKlxuICogT2J0aWVudCBsZXMgam91cnMgZsOpcmnDqXMgcG91ciB1bmUgYW5uw6llIGRvbm7DqWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvbGlkYXlzRm9yWWVhcih5ZWFyOiBudW1iZXIpOiBQdWJsaWNIb2xpZGF5W10ge1xuICBpZiAoeWVhciA9PT0gMjAyNCkgcmV0dXJuIEZSRU5DSF9IT0xJREFZU18yMDI0O1xuICBpZiAoeWVhciA9PT0gMjAyNSkgcmV0dXJuIEZSRU5DSF9IT0xJREFZU18yMDI1O1xuICBcbiAgLy8gUG91ciBsZXMgYXV0cmVzIGFubsOpZXMsIG9uIHBldXQgw6l0ZW5kcmUgb3UgdXRpbGlzZXIgdW5lIEFQSVxuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogQ2FsY3VsZSBsZSBzb2xkZSBkZSBjb25nw6lzIHBvdXIgY2hhcXVlIHR5cGUgZW4gaW5jbHVhbnQgbGVzIHJlbGlxdWF0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTGVhdmVCYWxhbmNlcyhcbiAgbGVhdmVzOiBMZWF2ZUVudHJ5W10sXG4gIHF1b3RhczogeyB0eXBlOiBMZWF2ZVR5cGU7IHllYXJseVF1b3RhOiBudW1iZXIgfVtdLFxuICBjYXJyeW92ZXJzOiBDYXJyeW92ZXJMZWF2ZVtdID0gW10sXG4gIHllYXI6IG51bWJlciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKVxuKTogTGVhdmVCYWxhbmNlW10ge1xuICBjb25zdCBiYWxhbmNlczogTGVhdmVCYWxhbmNlW10gPSBbXTtcblxuICBxdW90YXMuZm9yRWFjaChxdW90YSA9PiB7XG4gICAgY29uc3QgeWVhckxlYXZlcyA9IGxlYXZlcy5maWx0ZXIobGVhdmUgPT4gXG4gICAgICBsZWF2ZS50eXBlID09PSBxdW90YS50eXBlICYmIFxuICAgICAgbmV3IERhdGUobGVhdmUuc3RhcnREYXRlKS5nZXRGdWxsWWVhcigpID09PSB5ZWFyXG4gICAgKTtcblxuICAgIGNvbnN0IHVzZWQgPSB5ZWFyTGVhdmVzLnJlZHVjZSgodG90YWwsIGxlYXZlKSA9PiB0b3RhbCArIGxlYXZlLndvcmtpbmdEYXlzLCAwKTtcbiAgICBcbiAgICAvLyBDYWxjdWxlciBsZXMgcmVsaXF1YXRzIHBvdXIgY2UgdHlwZSBkZSBjb25nw6lcbiAgICBjb25zdCBjYXJyeW92ZXJEYXlzID0gY2FycnlvdmVyc1xuICAgICAgLmZpbHRlcihjYXJyeW92ZXIgPT4gY2FycnlvdmVyLnR5cGUgPT09IHF1b3RhLnR5cGUpXG4gICAgICAucmVkdWNlKCh0b3RhbCwgY2FycnlvdmVyKSA9PiB0b3RhbCArIGNhcnJ5b3Zlci5kYXlzLCAwKTtcbiAgICBcbiAgICAvLyBMZSB0b3RhbCBpbmNsdXQgbGUgcXVvdGEgYW5udWVsICsgbGVzIHJlbGlxdWF0c1xuICAgIGNvbnN0IHRvdGFsV2l0aENhcnJ5b3ZlciA9IHF1b3RhLnllYXJseVF1b3RhICsgY2FycnlvdmVyRGF5cztcbiAgICBjb25zdCByZW1haW5pbmcgPSBNYXRoLm1heCgwLCB0b3RhbFdpdGhDYXJyeW92ZXIgLSB1c2VkKTtcblxuICAgIGJhbGFuY2VzLnB1c2goe1xuICAgICAgdHlwZTogcXVvdGEudHlwZSxcbiAgICAgIHRvdGFsOiB0b3RhbFdpdGhDYXJyeW92ZXIsXG4gICAgICB1c2VkLFxuICAgICAgcmVtYWluaW5nLFxuICAgICAgY2FycnlvdmVyOiBjYXJyeW92ZXJEYXlzLFxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gYmFsYW5jZXM7XG59XG5cbi8qKlxuICogQ2FsY3VsZSBsZXMgcmVsaXF1YXRzIGRpc3BvbmlibGVzIHBvdXIgdW5lIGFubsOpZSBkb25uw6llXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVBdmFpbGFibGVDYXJyeW92ZXIoXG4gIGNhcnJ5b3ZlcnM6IENhcnJ5b3ZlckxlYXZlW10sXG4gIHllYXI6IG51bWJlciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKVxuKTogUmVjb3JkPExlYXZlVHlwZSwgbnVtYmVyPiB7XG4gIGNvbnN0IGF2YWlsYWJsZTogUmVjb3JkPExlYXZlVHlwZSwgbnVtYmVyPiA9IHtcbiAgICBjcDogMCwgcnR0OiAwLCBjZXQ6IDAsIHNpY2s6IDBcbiAgfTtcblxuICBjYXJyeW92ZXJzLmZvckVhY2goY2FycnlvdmVyID0+IHtcbiAgICBhdmFpbGFibGVbY2FycnlvdmVyLnR5cGVdICs9IGNhcnJ5b3Zlci5kYXlzO1xuICB9KTtcblxuICByZXR1cm4gYXZhaWxhYmxlO1xufVxuXG4vKipcbiAqIEfDqW7DqHJlIHVuIHLDqXN1bcOpIGRlcyByZWxpcXVhdHMgcGFyIGFubsOpZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDYXJyeW92ZXJTdW1tYXJ5KGNhcnJ5b3ZlcnM6IENhcnJ5b3ZlckxlYXZlW10pOiB7XG4gIGJ5WWVhcjogUmVjb3JkPG51bWJlciwgQ2FycnlvdmVyTGVhdmVbXT47XG4gIGJ5VHlwZTogUmVjb3JkPExlYXZlVHlwZSwgQ2FycnlvdmVyTGVhdmVbXT47XG4gIHRvdGFsQnlUeXBlOiBSZWNvcmQ8TGVhdmVUeXBlLCBudW1iZXI+O1xufSB7XG4gIGNvbnN0IGJ5WWVhcjogUmVjb3JkPG51bWJlciwgQ2FycnlvdmVyTGVhdmVbXT4gPSB7fTtcbiAgY29uc3QgYnlUeXBlOiBSZWNvcmQ8TGVhdmVUeXBlLCBDYXJyeW92ZXJMZWF2ZVtdPiA9IHtcbiAgICBjcDogW10sIHJ0dDogW10sIGNldDogW10sIHNpY2s6IFtdXG4gIH07XG4gIGNvbnN0IHRvdGFsQnlUeXBlOiBSZWNvcmQ8TGVhdmVUeXBlLCBudW1iZXI+ID0ge1xuICAgIGNwOiAwLCBydHQ6IDAsIGNldDogMCwgc2ljazogMFxuICB9O1xuXG4gIGNhcnJ5b3ZlcnMuZm9yRWFjaChjYXJyeW92ZXIgPT4ge1xuICAgIC8vIFBhciBhbm7DqWVcbiAgICBpZiAoIWJ5WWVhcltjYXJyeW92ZXIueWVhcl0pIHtcbiAgICAgIGJ5WWVhcltjYXJyeW92ZXIueWVhcl0gPSBbXTtcbiAgICB9XG4gICAgYnlZZWFyW2NhcnJ5b3Zlci55ZWFyXS5wdXNoKGNhcnJ5b3Zlcik7XG5cbiAgICAvLyBQYXIgdHlwZVxuICAgIGJ5VHlwZVtjYXJyeW92ZXIudHlwZV0ucHVzaChjYXJyeW92ZXIpO1xuICAgIHRvdGFsQnlUeXBlW2NhcnJ5b3Zlci50eXBlXSArPSBjYXJyeW92ZXIuZGF5cztcbiAgfSk7XG5cbiAgcmV0dXJuIHsgYnlZZWFyLCBieVR5cGUsIHRvdGFsQnlUeXBlIH07XG59XG5cbi8qKlxuICogVmFsaWRlIHNpIGxlcyBSVFQgcGV1dmVudCDDqnRyZSBwcmlzIHBvdXIgdW4gbW9pcyBkb25uw6lcbiAqIExlcyBSVFQgcydhY2N1bXVsZW50IMOgIGxhIGZpbiBkdSBtb2lzLCBkb25jIG9uIG5lIHBldXQgbGVzIHByZW5kcmVcbiAqIHF1ZSBzaSBsZSBtb2lzIGNvcnJlc3BvbmRhbnQgZXN0IHBhc3PDqVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuVGFrZVJUVEZvck1vbnRoKFxuICB0YXJnZXRNb250aDogbnVtYmVyLCAvLyAxLTEyXG4gIHRhcmdldFllYXI6IG51bWJlcixcbiAgY3VycmVudERhdGU6IERhdGUgPSBuZXcgRGF0ZSgpXG4pOiB7IGNhblRha2U6IGJvb2xlYW47IHJlYXNvbj86IHN0cmluZzsgYXZhaWxhYmxlRGF5czogbnVtYmVyIH0ge1xuICBjb25zdCBjdXJyZW50TW9udGggPSBjdXJyZW50RGF0ZS5nZXRNb250aCgpICsgMTsgLy8gMS0xMlxuICBjb25zdCBjdXJyZW50WWVhciA9IGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCk7XG4gIFxuICAvLyBTaSBvbiBlc3QgZGFucyB1bmUgYW5uw6llIGZ1dHVyZSwgb24gbmUgcGV1dCBwYXMgZW5jb3JlIHByZW5kcmUgbGVzIFJUVFxuICBpZiAodGFyZ2V0WWVhciA+IGN1cnJlbnRZZWFyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhblRha2U6IGZhbHNlLFxuICAgICAgcmVhc29uOiBgTGVzIFJUVCBkZSAke3RhcmdldFllYXJ9IG5lIHNvbnQgcGFzIGVuY29yZSBkaXNwb25pYmxlc2AsXG4gICAgICBhdmFpbGFibGVEYXlzOiAwXG4gICAgfTtcbiAgfVxuICBcbiAgLy8gU2kgb24gZXN0IGRhbnMgdW5lIGFubsOpZSBwYXNzw6llLCBvbiBwZXV0IHByZW5kcmUgbGVzIFJUVFxuICBpZiAodGFyZ2V0WWVhciA8IGN1cnJlbnRZZWFyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhblRha2U6IHRydWUsXG4gICAgICBhdmFpbGFibGVEYXlzOiAyIC8vIDIgUlRUIHBhciBtb2lzXG4gICAgfTtcbiAgfVxuICBcbiAgLy8gTcOqbWUgYW5uw6llIDogdsOpcmlmaWVyIHNpIGxlIG1vaXMgZXN0IHBhc3PDqVxuICBpZiAodGFyZ2V0TW9udGggPCBjdXJyZW50TW9udGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FuVGFrZTogdHJ1ZSxcbiAgICAgIGF2YWlsYWJsZURheXM6IDJcbiAgICB9O1xuICB9IGVsc2UgaWYgKHRhcmdldE1vbnRoID09PSBjdXJyZW50TW9udGgpIHtcbiAgICAvLyBQb3VyIGxlIG1vaXMgZW4gY291cnMsIG9uIHBldXQgcHJlbmRyZSBsZXMgUlRUIGTDqHMgbGUgZMOpYnV0IGR1IG1vaXNcbiAgICByZXR1cm4ge1xuICAgICAgY2FuVGFrZTogdHJ1ZSxcbiAgICAgIGF2YWlsYWJsZURheXM6IDJcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIE1vaXMgZnV0dXIgLSBwb3NzaWJsZSBlbiBwcsOpdmlzaW9uXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhblRha2U6IHRydWUsXG4gICAgICBhdmFpbGFibGVEYXlzOiAyLFxuICAgICAgcmVhc29uOiBgUlRUIGRpc3BvbmlibGUgZW4gcHLDqXZpc2lvbiBwb3VyICR7dGFyZ2V0WWVhcn1gXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGUgbGUgbm9tYnJlIHRvdGFsIGRlIFJUVCBkaXNwb25pYmxlcyBwb3VyIHVuZSBww6lyaW9kZSBkb25uw6llXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVBdmFpbGFibGVSVFRGb3JQZXJpb2QoXG4gIHN0YXJ0RGF0ZTogRGF0ZSxcbiAgZW5kRGF0ZTogRGF0ZSxcbiAgY3VycmVudERhdGU6IERhdGUgPSBuZXcgRGF0ZSgpXG4pOiB7IHRvdGFsQXZhaWxhYmxlOiBudW1iZXI7IGRldGFpbHM6IEFycmF5PHsgbW9udGg6IG51bWJlcjsgeWVhcjogbnVtYmVyOyBhdmFpbGFibGU6IG51bWJlcjsgY2FuVGFrZTogYm9vbGVhbiB9PiB9IHtcbiAgY29uc3QgZGV0YWlsczogQXJyYXk8eyBtb250aDogbnVtYmVyOyB5ZWFyOiBudW1iZXI7IGF2YWlsYWJsZTogbnVtYmVyOyBjYW5UYWtlOiBib29sZWFuIH0+ID0gW107XG4gIGxldCB0b3RhbEF2YWlsYWJsZSA9IDA7XG4gIFxuICBjb25zdCBjdXJyZW50ID0gbmV3IERhdGUoc3RhcnREYXRlKTtcbiAgXG4gIHdoaWxlIChjdXJyZW50IDw9IGVuZERhdGUpIHtcbiAgICBjb25zdCBtb250aCA9IGN1cnJlbnQuZ2V0TW9udGgoKSArIDE7XG4gICAgY29uc3QgeWVhciA9IGN1cnJlbnQuZ2V0RnVsbFllYXIoKTtcbiAgICBcbiAgICBjb25zdCB2YWxpZGF0aW9uID0gY2FuVGFrZVJUVEZvck1vbnRoKG1vbnRoLCB5ZWFyLCBjdXJyZW50RGF0ZSk7XG4gICAgXG4gICAgZGV0YWlscy5wdXNoKHtcbiAgICAgIG1vbnRoLFxuICAgICAgeWVhcixcbiAgICAgIGF2YWlsYWJsZTogdmFsaWRhdGlvbi5hdmFpbGFibGVEYXlzLFxuICAgICAgY2FuVGFrZTogdmFsaWRhdGlvbi5jYW5UYWtlXG4gICAgfSk7XG4gICAgXG4gICAgLy8gUG91ciBsZXMgcHLDqXZpc2lvbnMsIG9uIGNvbXB0ZSB0b3VzIGxlcyBtb2lzIChwYXNzw6lzLCBwcsOpc2VudHMgZXQgZnV0dXJzKVxuICAgIHRvdGFsQXZhaWxhYmxlICs9IHZhbGlkYXRpb24uYXZhaWxhYmxlRGF5cztcbiAgICBcbiAgICAvLyBQYXNzZXIgYXUgbW9pcyBzdWl2YW50XG4gICAgY3VycmVudC5zZXRNb250aChjdXJyZW50LmdldE1vbnRoKCkgKyAxKTtcbiAgfVxuICBcbiAgcmV0dXJuIHsgdG90YWxBdmFpbGFibGUsIGRldGFpbHMgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxlIGxlIG5vbWJyZSB0b3RhbCBkZSBSVFQgZGlzcG9uaWJsZXMgYWN0dWVsbGVtZW50XG4gKiAoZGVwdWlzIGxlIGTDqWJ1dCBkZSBsJ2FubsOpZSBqdXNxdSfDoCBtYWludGVuYW50KVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQ3VycmVudEF2YWlsYWJsZVJUVChcbiAgY3VycmVudERhdGU6IERhdGUgPSBuZXcgRGF0ZSgpLFxuICB5ZWFyOiBudW1iZXIgPSBjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpXG4pOiB7IHRvdGFsQXZhaWxhYmxlOiBudW1iZXI7IGRldGFpbHM6IEFycmF5PHsgbW9udGg6IG51bWJlcjsgYXZhaWxhYmxlOiBudW1iZXI7IGNhblRha2U6IGJvb2xlYW47IHJlYXNvbj86IHN0cmluZyB9PiB9IHtcbiAgY29uc3QgZGV0YWlsczogQXJyYXk8eyBtb250aDogbnVtYmVyOyBhdmFpbGFibGU6IG51bWJlcjsgY2FuVGFrZTogYm9vbGVhbjsgcmVhc29uPzogc3RyaW5nIH0+ID0gW107XG4gIGxldCB0b3RhbEF2YWlsYWJsZSA9IDA7XG4gIFxuICAvLyBQYXJjb3VyaXIgdG91cyBsZXMgbW9pcyBkZSBsJ2FubsOpZSAoeSBjb21wcmlzIGxlcyBtb2lzIGZ1dHVycyBlbiBwcsOpdmlzaW9uKVxuICBmb3IgKGxldCBtb250aCA9IDE7IG1vbnRoIDw9IDEyOyBtb250aCsrKSB7XG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IGNhblRha2VSVFRGb3JNb250aChtb250aCwgeWVhciwgY3VycmVudERhdGUpO1xuICAgIFxuICAgIGRldGFpbHMucHVzaCh7XG4gICAgICBtb250aCxcbiAgICAgIGF2YWlsYWJsZTogdmFsaWRhdGlvbi5hdmFpbGFibGVEYXlzLFxuICAgICAgY2FuVGFrZTogdmFsaWRhdGlvbi5jYW5UYWtlLFxuICAgICAgcmVhc29uOiB2YWxpZGF0aW9uLnJlYXNvblxuICAgIH0pO1xuICAgIFxuICAgIC8vIFBvdXIgbGVzIHByw6l2aXNpb25zLCBvbiBjb21wdGUgdG91cyBsZXMgbW9pcyAocGFzc8OpcywgcHLDqXNlbnRzIGV0IGZ1dHVycylcbiAgICB0b3RhbEF2YWlsYWJsZSArPSB2YWxpZGF0aW9uLmF2YWlsYWJsZURheXM7XG4gIH1cbiAgXG4gIHJldHVybiB7IHRvdGFsQXZhaWxhYmxlLCBkZXRhaWxzIH07XG59XG5cbi8vIE5vdXZlbGxlIGZvbmN0aW9uIHBvdXIgY2FsY3VsZXIgbGVzIGRvbm7DqWVzIHPDqXBhcsOpZXMgcGFyIHR5cGUgKHLDqWVsIHZzIHByw6l2aXNpb24pXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTW9udGhseUxlYXZlU3VtbWFyeVNlcGFyYXRlZChcbiAgbGVhdmVzOiBMZWF2ZUVudHJ5W10sXG4gIHF1b3RhczogeyB0eXBlOiBMZWF2ZVR5cGU7IHllYXJseVF1b3RhOiBudW1iZXIgfVtdLFxuICBjYXJyeW92ZXJzOiBDYXJyeW92ZXJMZWF2ZVtdID0gW10sXG4gIHllYXI6IG51bWJlciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKVxuKToge1xuICBtb250aHM6IEFycmF5PHtcbiAgICBtb250aDogbnVtYmVyO1xuICAgIG1vbnRoTmFtZTogc3RyaW5nO1xuICAgIHJ0dDoge1xuICAgICAgcmVhbDogeyB0YWtlbjogbnVtYmVyOyBjdW11bDogbnVtYmVyOyByZW1haW5pbmc6IG51bWJlciB9O1xuICAgICAgZm9yZWNhc3Q6IHsgdGFrZW46IG51bWJlcjsgY3VtdWw6IG51bWJlcjsgcmVtYWluaW5nOiBudW1iZXIgfTtcbiAgICB9O1xuICAgIGNwOiB7XG4gICAgICByZWFsOiB7IHRha2VuOiBudW1iZXI7IGN1bXVsOiBudW1iZXI7IHJlbWFpbmluZzogbnVtYmVyIH07XG4gICAgICBmb3JlY2FzdDogeyB0YWtlbjogbnVtYmVyOyBjdW11bDogbnVtYmVyOyByZW1haW5pbmc6IG51bWJlciB9O1xuICAgIH07XG4gIH0+O1xuICB5ZWFybHlUb3RhbHM6IHtcbiAgICBydHQ6IHsgcmVhbDogbnVtYmVyOyBmb3JlY2FzdDogbnVtYmVyOyB0b3RhbDogbnVtYmVyIH07XG4gICAgY3A6IHsgcmVhbDogbnVtYmVyOyBmb3JlY2FzdDogbnVtYmVyOyB0b3RhbDogbnVtYmVyIH07XG4gIH07XG59IHtcbiAgY29uc3QgbW9udGhzID0gW107XG4gIGNvbnN0IG1vbnRoTmFtZXMgPSBbXG4gICAgJ0phbnZpZXInLCAnRsOpdnJpZXInLCAnTWFycycsICdBdnJpbCcsICdNYWknLCAnSnVpbicsXG4gICAgJ0p1aWxsZXQnLCAnQW/Du3QnLCAnU2VwdGVtYnJlJywgJ09jdG9icmUnLCAnTm92ZW1icmUnLCAnRMOpY2VtYnJlJ1xuICBdO1xuXG4gIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcbiAgY29uc3QgY3VycmVudE1vbnRoID0gY3VycmVudERhdGUuZ2V0TW9udGgoKSArIDE7IC8vIDEtMTJcbiAgY29uc3QgY3VycmVudFllYXIgPSBjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gIC8vIFLDqWN1cMOpcmVyIGxlcyBxdW90YXNcbiAgY29uc3QgcnR0UXVvdGEgPSBxdW90YXMuZmluZChxID0+IHEudHlwZSA9PT0gJ3J0dCcpPy55ZWFybHlRdW90YSB8fCAyMztcbiAgY29uc3QgY3BRdW90YSA9IHF1b3Rhcy5maW5kKHEgPT4gcS50eXBlID09PSAnY3AnKT8ueWVhcmx5UXVvdGEgfHwgMjU7XG4gIGNvbnN0IGNldFF1b3RhID0gcXVvdGFzLmZpbmQocSA9PiBxLnR5cGUgPT09ICdjZXQnKT8ueWVhcmx5UXVvdGEgfHwgNTtcbiAgY29uc3QgdG90YWxDUENFVFF1b3RhID0gY3BRdW90YSArIGNldFF1b3RhO1xuXG4gIC8vIFLDqWN1cMOpcmVyIGxlcyByZWxpcXVhdHNcbiAgY29uc3QgcnR0Q2FycnlvdmVyID0gY2FycnlvdmVycy5maW5kKGMgPT4gYy50eXBlID09PSAncnR0Jyk/LmRheXMgfHwgMDtcbiAgY29uc3QgY3BDYXJyeW92ZXIgPSBjYXJyeW92ZXJzLmZpbmQoYyA9PiBjLnR5cGUgPT09ICdjcCcpPy5kYXlzIHx8IDA7XG4gIGNvbnN0IGNldENhcnJ5b3ZlciA9IGNhcnJ5b3ZlcnMuZmluZChjID0+IGMudHlwZSA9PT0gJ2NldCcpPy5kYXlzIHx8IDA7XG4gIGNvbnN0IHRvdGFsQ1BDRVRDYXJyeW92ZXIgPSBjcENhcnJ5b3ZlciArIGNldENhcnJ5b3ZlcjtcblxuICAvLyBBam91dGVyIGxhIGxpZ25lIGRlcyByZWxpcXVhdHMgYXUgZMOpYnV0XG4gIG1vbnRocy5wdXNoKHtcbiAgICBtb250aDogMCxcbiAgICBtb250aE5hbWU6ICdSZWxpcXVhdHMnLFxuICAgIHJ0dDoge1xuICAgICAgcmVhbDogeyB0YWtlbjogMCwgY3VtdWw6IDAsIHJlbWFpbmluZzogcnR0Q2FycnlvdmVyIH0sXG4gICAgICBmb3JlY2FzdDogeyB0YWtlbjogMCwgY3VtdWw6IDAsIHJlbWFpbmluZzogcnR0Q2FycnlvdmVyIH1cbiAgICB9LFxuICAgIGNwOiB7XG4gICAgICByZWFsOiB7IHRha2VuOiAwLCBjdW11bDogMCwgcmVtYWluaW5nOiB0b3RhbENQQ0VUQ2FycnlvdmVyIH0sXG4gICAgICBmb3JlY2FzdDogeyB0YWtlbjogMCwgY3VtdWw6IDAsIHJlbWFpbmluZzogdG90YWxDUENFVENhcnJ5b3ZlciB9XG4gICAgfVxuICB9KTtcblxuICBsZXQgcnR0Q3VtdWxSZWFsID0gMDtcbiAgbGV0IHJ0dEN1bXVsRm9yZWNhc3QgPSAwO1xuICBsZXQgY3BDdW11bFJlYWwgPSAwO1xuICBsZXQgY3BDdW11bEZvcmVjYXN0ID0gMDtcblxuICBmb3IgKGxldCBtb250aCA9IDE7IG1vbnRoIDw9IDEyOyBtb250aCsrKSB7XG4gICAgLy8gRmlsdHJlciBsZXMgY29uZ8OpcyBwb3VyIGNlIG1vaXMgZXQgY2V0dGUgYW5uw6llXG4gICAgY29uc3QgbW9udGhMZWF2ZXMgPSBsZWF2ZXMuZmlsdGVyKGxlYXZlID0+IHtcbiAgICAgIGNvbnN0IGxlYXZlRGF0ZSA9IG5ldyBEYXRlKGxlYXZlLnN0YXJ0RGF0ZSk7XG4gICAgICByZXR1cm4gbGVhdmVEYXRlLmdldEZ1bGxZZWFyKCkgPT09IHllYXIgJiYgbGVhdmVEYXRlLmdldE1vbnRoKCkgPT09IG1vbnRoIC0gMTtcbiAgICB9KTtcblxuICAgIC8vIFPDqXBhcmVyIGxlcyBjb25nw6lzIHLDqWVscyBldCBsZXMgcHLDqXZpc2lvbnNcbiAgICAvLyBTaSBsZSBtb2lzIGVzdCBwYXNzw6ksIGxlcyBwcsOpdmlzaW9ucyBkZXZpZW5uZW50IHLDqWVsbGVzXG4gICAgY29uc3QgaXNNb250aFBhc3NlZCA9IHllYXIgPCBjdXJyZW50WWVhciB8fCAoeWVhciA9PT0gY3VycmVudFllYXIgJiYgbW9udGggPCBjdXJyZW50TW9udGgpO1xuICAgIGNvbnN0IGlzQ3VycmVudE1vbnRoID0geWVhciA9PT0gY3VycmVudFllYXIgJiYgbW9udGggPT09IGN1cnJlbnRNb250aDtcbiAgICBcbiAgICAvLyBDb25nw6lzIHLDqWVscyA6IHRvdXMgbGVzIGNvbmfDqXMgbm9uIG1hcnF1w6lzIGNvbW1lIHByw6l2aXNpb24gT1UgbGVzIHByw6l2aXNpb25zIGRlcyBtb2lzIHBhc3PDqXNcbiAgICBjb25zdCBydHRSZWFsID0gbW9udGhMZWF2ZXNcbiAgICAgIC5maWx0ZXIobGVhdmUgPT4gbGVhdmUudHlwZSA9PT0gJ3J0dCcgJiYgKCFsZWF2ZS5pc0ZvcmVjYXN0IHx8IGlzTW9udGhQYXNzZWQpKVxuICAgICAgLnJlZHVjZSgoc3VtLCBsZWF2ZSkgPT4gc3VtICsgbGVhdmUud29ya2luZ0RheXMsIDApO1xuXG4gICAgY29uc3QgY3BSZWFsID0gbW9udGhMZWF2ZXNcbiAgICAgIC5maWx0ZXIobGVhdmUgPT4gbGVhdmUudHlwZSA9PT0gJ2NwJyAmJiAoIWxlYXZlLmlzRm9yZWNhc3QgfHwgaXNNb250aFBhc3NlZCkpXG4gICAgICAucmVkdWNlKChzdW0sIGxlYXZlKSA9PiBzdW0gKyBsZWF2ZS53b3JraW5nRGF5cywgMCk7XG5cbiAgICAvLyBQb3VyIGxlcyBwcsOpdmlzaW9ucywgY29tcHRlciBsZXMgY29uZ8OpcyBtYXJxdcOpcyBjb21tZSBwcsOpdmlzaW9uIGRlcyBtb2lzIGZ1dHVyc1xuICAgIC8vIEVUIGxlcyBjb25nw6lzIG5vbiBtYXJxdcOpcyBjb21tZSBwcsOpdmlzaW9uIGRlcyBtb2lzIGZ1dHVycyAocG91ciBzaW11bGF0aW9uKVxuICAgIGNvbnN0IHJ0dEZvcmVjYXN0ID0gbW9udGhMZWF2ZXNcbiAgICAgIC5maWx0ZXIobGVhdmUgPT4gbGVhdmUudHlwZSA9PT0gJ3J0dCcgJiYgKGxlYXZlLmlzRm9yZWNhc3QgfHwgKCFpc01vbnRoUGFzc2VkICYmICFpc0N1cnJlbnRNb250aCkpKVxuICAgICAgLnJlZHVjZSgoc3VtLCBsZWF2ZSkgPT4gc3VtICsgbGVhdmUud29ya2luZ0RheXMsIDApO1xuXG4gICAgY29uc3QgY3BGb3JlY2FzdCA9IG1vbnRoTGVhdmVzXG4gICAgICAuZmlsdGVyKGxlYXZlID0+IGxlYXZlLnR5cGUgPT09ICdjcCcgJiYgKGxlYXZlLmlzRm9yZWNhc3QgfHwgKCFpc01vbnRoUGFzc2VkICYmICFpc0N1cnJlbnRNb250aCkpKVxuICAgICAgLnJlZHVjZSgoc3VtLCBsZWF2ZSkgPT4gc3VtICsgbGVhdmUud29ya2luZ0RheXMsIDApO1xuXG4gICAgLy8gQ2FsY3VsZXIgbGVzIGN1bXVsc1xuICAgIHJ0dEN1bXVsUmVhbCArPSBydHRSZWFsO1xuICAgIHJ0dEN1bXVsRm9yZWNhc3QgKz0gcnR0Rm9yZWNhc3Q7XG4gICAgY3BDdW11bFJlYWwgKz0gY3BSZWFsO1xuICAgIGNwQ3VtdWxGb3JlY2FzdCArPSBjcEZvcmVjYXN0O1xuXG4gICAgLy8gQ2FsY3VsZXIgbGVzIHNvbGRlcyByZXN0YW50cyAoY3VtdWxzIGludmVyc8OpcylcbiAgICAvLyBMZXMgcmVsaXF1YXRzIHNvbnQgZMOpasOgIGluY2x1cyBkYW5zIGxlcyBxdW90YXMgdG90YXV4XG4gICAgY29uc3QgcnR0UmVtYWluaW5nUmVhbCA9IE1hdGgubWF4KDAsIHJ0dFF1b3RhICsgcnR0Q2FycnlvdmVyIC0gcnR0Q3VtdWxSZWFsKTtcbiAgICBjb25zdCBydHRSZW1haW5pbmdGb3JlY2FzdCA9IE1hdGgubWF4KDAsIHJ0dFF1b3RhICsgcnR0Q2FycnlvdmVyIC0gcnR0Q3VtdWxSZWFsIC0gcnR0Q3VtdWxGb3JlY2FzdCk7XG4gICAgY29uc3QgY3BSZW1haW5pbmdSZWFsID0gTWF0aC5tYXgoMCwgdG90YWxDUENFVFF1b3RhICsgdG90YWxDUENFVENhcnJ5b3ZlciAtIGNwQ3VtdWxSZWFsKTtcbiAgICBjb25zdCBjcFJlbWFpbmluZ0ZvcmVjYXN0ID0gTWF0aC5tYXgoMCwgdG90YWxDUENFVFF1b3RhICsgdG90YWxDUENFVENhcnJ5b3ZlciAtIGNwQ3VtdWxSZWFsIC0gY3BDdW11bEZvcmVjYXN0KTtcblxuICAgIG1vbnRocy5wdXNoKHtcbiAgICAgIG1vbnRoLFxuICAgICAgbW9udGhOYW1lOiBtb250aE5hbWVzW21vbnRoIC0gMV0sXG4gICAgICBydHQ6IHtcbiAgICAgICAgcmVhbDogeyB0YWtlbjogcnR0UmVhbCwgY3VtdWw6IHJ0dEN1bXVsUmVhbCwgcmVtYWluaW5nOiBydHRSZW1haW5pbmdSZWFsIH0sXG4gICAgICAgIGZvcmVjYXN0OiB7IHRha2VuOiBydHRGb3JlY2FzdCwgY3VtdWw6IHJ0dEN1bXVsRm9yZWNhc3QsIHJlbWFpbmluZzogcnR0UmVtYWluaW5nRm9yZWNhc3QgfVxuICAgICAgfSxcbiAgICAgIGNwOiB7XG4gICAgICAgIHJlYWw6IHsgdGFrZW46IGNwUmVhbCwgY3VtdWw6IGNwQ3VtdWxSZWFsLCByZW1haW5pbmc6IGNwUmVtYWluaW5nUmVhbCB9LFxuICAgICAgICBmb3JlY2FzdDogeyB0YWtlbjogY3BGb3JlY2FzdCwgY3VtdWw6IGNwQ3VtdWxGb3JlY2FzdCwgcmVtYWluaW5nOiBjcFJlbWFpbmluZ0ZvcmVjYXN0IH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbW9udGhzLFxuICAgIHllYXJseVRvdGFsczoge1xuICAgICAgcnR0OiB7IHJlYWw6IHJ0dEN1bXVsUmVhbCwgZm9yZWNhc3Q6IHJ0dEN1bXVsRm9yZWNhc3QsIHRvdGFsOiBydHRDdW11bFJlYWwgKyBydHRDdW11bEZvcmVjYXN0IH0sXG4gICAgICBjcDogeyByZWFsOiBjcEN1bXVsUmVhbCwgZm9yZWNhc3Q6IGNwQ3VtdWxGb3JlY2FzdCwgdG90YWw6IGNwQ3VtdWxSZWFsICsgY3BDdW11bEZvcmVjYXN0IH1cbiAgICB9XG4gIH07XG59XG5cbi8vIEZvbmN0aW9uIHV0aWxpdGFpcmUgcG91ciB2w6lyaWZpZXIgc2kgZGV1eCBjb25nw6lzIGNvcnJlc3BvbmRlbnQgw6AgbGEgbcOqbWUgcMOpcmlvZGVcbmZ1bmN0aW9uIGlzU2FtZVBlcmlvZChmb3JlY2FzdDogTGVhdmVFbnRyeSwgcmVhbDogTGVhdmVFbnRyeSk6IGJvb2xlYW4ge1xuICAvLyBTaSBjJ2VzdCB1biBzZXVsIGpvdXIsIHbDqXJpZmllciBsYSBkYXRlIGV4YWN0ZVxuICBpZiAoZm9yZWNhc3Qud29ya2luZ0RheXMgPT09IDEgJiYgcmVhbC53b3JraW5nRGF5cyA9PT0gMSkge1xuICAgIHJldHVybiBmb3JlY2FzdC5zdGFydERhdGUgPT09IHJlYWwuc3RhcnREYXRlO1xuICB9XG4gIFxuICAvLyBTaSBjJ2VzdCB1bmUgcMOpcmlvZGUsIHbDqXJpZmllciBzaSBsZXMgZGF0ZXMgc2UgY2hldmF1Y2hlbnRcbiAgY29uc3QgZm9yZWNhc3RTdGFydCA9IG5ldyBEYXRlKGZvcmVjYXN0LnN0YXJ0RGF0ZSk7XG4gIGNvbnN0IGZvcmVjYXN0RW5kID0gbmV3IERhdGUoZm9yZWNhc3QuZW5kRGF0ZSk7XG4gIGNvbnN0IHJlYWxTdGFydCA9IG5ldyBEYXRlKHJlYWwuc3RhcnREYXRlKTtcbiAgY29uc3QgcmVhbEVuZCA9IG5ldyBEYXRlKHJlYWwuZW5kRGF0ZSk7XG4gIFxuICAvLyBWw6lyaWZpZXIgc2kgbGVzIHDDqXJpb2RlcyBzZSBjaGV2YXVjaGVudFxuICByZXR1cm4gZm9yZWNhc3RTdGFydCA8PSByZWFsRW5kICYmIHJlYWxTdGFydCA8PSBmb3JlY2FzdEVuZDtcbn1cblxuXG4vKipcbiAqIEfDqW7DqHJlIGxlcyBkb25uw6llcyBkdSBjYWxlbmRyaWVyIHBvdXIgdW4gbW9pcyBkb25uw6lcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ2FsZW5kYXJEYXlzKFxuICB5ZWFyOiBudW1iZXIsXG4gIG1vbnRoOiBudW1iZXIsXG4gIGxlYXZlczogTGVhdmVFbnRyeVtdLFxuICBob2xpZGF5czogUHVibGljSG9saWRheVtdXG4pOiBDYWxlbmRhckRheVtdIHtcbiAgY29uc3QgZGF5czogQ2FsZW5kYXJEYXlbXSA9IFtdO1xuICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIDEpO1xuICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDApO1xuXG4gIGxldCBjdXJyZW50RGF0ZSA9IHN0YXJ0RGF0ZTtcbiAgd2hpbGUgKGN1cnJlbnREYXRlIDw9IGVuZERhdGUpIHtcbiAgICBjb25zdCBkYXRlU3RyID0gZm9ybWF0KGN1cnJlbnREYXRlLCAneXl5eS1NTS1kZCcpO1xuICAgIGNvbnN0IGxlYXZlID0gbGVhdmVzLmZpbmQobCA9PiB7XG4gICAgICBjb25zdCBsZWF2ZVN0YXJ0ID0gbmV3IERhdGUobC5zdGFydERhdGUpO1xuICAgICAgY29uc3QgbGVhdmVFbmQgPSBuZXcgRGF0ZShsLmVuZERhdGUpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaXNTYW1lRGF5KGN1cnJlbnREYXRlLCBsZWF2ZVN0YXJ0KSB8fFxuICAgICAgICBpc1NhbWVEYXkoY3VycmVudERhdGUsIGxlYXZlRW5kKSB8fFxuICAgICAgICAoaXNBZnRlcihjdXJyZW50RGF0ZSwgbGVhdmVTdGFydCkgJiYgaXNCZWZvcmUoY3VycmVudERhdGUsIGxlYXZlRW5kKSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBob2xpZGF5ID0gaG9saWRheXMuZmluZChoID0+IHtcbiAgICAgIGNvbnN0IGhvbGlkYXlEYXRlID0gbmV3IERhdGUoaC5kYXRlKTtcbiAgICAgIHJldHVybiBpc1NhbWVEYXkoY3VycmVudERhdGUsIGhvbGlkYXlEYXRlKTtcbiAgICB9KTtcblxuICAgIGRheXMucHVzaCh7XG4gICAgICBkYXRlOiBkYXRlU3RyLFxuICAgICAgaXNMZWF2ZTogISFsZWF2ZSxcbiAgICAgIGxlYXZlVHlwZTogbGVhdmU/LnR5cGUsXG4gICAgICBpc1dlZWtlbmQ6IGlzV2Vla2VuZChjdXJyZW50RGF0ZSksXG4gICAgICBpc0hvbGlkYXk6ICEhaG9saWRheSxcbiAgICAgIGhvbGlkYXlOYW1lOiBob2xpZGF5Py5uYW1lLFxuICAgIH0pO1xuXG4gICAgY3VycmVudERhdGUgPSBhZGREYXlzKGN1cnJlbnREYXRlLCAxKTtcbiAgfVxuXG4gIHJldHVybiBkYXlzO1xufVxuXG4vKipcbiAqIEZvcm1hdGUgdW5lIGRhdGUgcG91ciBsJ2FmZmljaGFnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlOiBzdHJpbmcgfCBEYXRlLCBmb3JtYXRTdHI6IHN0cmluZyA9ICdkZC9NTS95eXl5Jyk6IHN0cmluZyB7XG4gIGNvbnN0IGRhdGVPYmogPSB0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycgPyBuZXcgRGF0ZShkYXRlKSA6IGRhdGU7XG4gIFxuICAvLyBWYWxpZGF0ZSB0aGUgZGF0ZVxuICBpZiAoaXNOYU4oZGF0ZU9iai5nZXRUaW1lKCkpKSB7XG4gICAgY29uc29sZS5lcnJvcignSW52YWxpZCBkYXRlIGZvciBmb3JtYXR0aW5nOicsIGRhdGUpO1xuICAgIHJldHVybiAnRGF0ZSBpbnZhbGlkZSc7XG4gIH1cbiAgXG4gIHJldHVybiBmb3JtYXQoZGF0ZU9iaiwgZm9ybWF0U3RyLCB7IGxvY2FsZTogZnIgfSk7XG59XG5cbi8qKlxuICogT2J0aWVudCBsZSBub20gZHUgdHlwZSBkZSBjb25nw6lcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExlYXZlVHlwZUxhYmVsKHR5cGU6IExlYXZlVHlwZSk6IHN0cmluZyB7XG4gIHJldHVybiBMRUFWRV9UWVBFU1t0eXBlXS5sYWJlbDtcbn1cblxuLyoqXG4gKiBPYnRpZW50IGxhIGNvdWxldXIgZHUgdHlwZSBkZSBjb25nw6lcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExlYXZlVHlwZUNvbG9yKHR5cGU6IExlYXZlVHlwZSk6IHN0cmluZyB7XG4gIHJldHVybiBMRUFWRV9UWVBFU1t0eXBlXS5jb2xvcjtcbn1cblxuLyoqXG4gKiBPYnRpZW50IGwnaWPDtG5lIGR1IHR5cGUgZGUgY29uZ8OpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWF2ZVR5cGVJY29uKHR5cGU6IExlYXZlVHlwZSk6IHN0cmluZyB7XG4gIHJldHVybiBMRUFWRV9UWVBFU1t0eXBlXS5pY29uO1xufVxuXG4vKipcbiAqIFZhbGlkZSB1bmUgcMOpcmlvZGUgZGUgY29uZ8Opc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVMZWF2ZVBlcmlvZChcbiAgc3RhcnREYXRlOiBzdHJpbmcsXG4gIGVuZERhdGU6IHN0cmluZyxcbiAgZXhpc3RpbmdMZWF2ZXM6IExlYXZlRW50cnlbXSxcbiAgZXhjbHVkZUlkPzogc3RyaW5nXG4pOiB7IGlzVmFsaWQ6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0ge1xuICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSk7XG4gIGNvbnN0IGVuZCA9IG5ldyBEYXRlKGVuZERhdGUpO1xuXG4gIGlmIChpc0FmdGVyKHN0YXJ0LCBlbmQpKSB7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiAnTGEgZGF0ZSBkZSBkw6lidXQgZG9pdCDDqnRyZSBhbnTDqXJpZXVyZSDDoCBsYSBkYXRlIGRlIGZpbicgfTtcbiAgfVxuXG4gIC8vIFbDqXJpZmllciBsZXMgY2hldmF1Y2hlbWVudHMgYXZlYyBsZXMgY29uZ8OpcyBleGlzdGFudHNcbiAgY29uc3Qgb3ZlcmxhcHBpbmcgPSBleGlzdGluZ0xlYXZlc1xuICAgIC5maWx0ZXIobGVhdmUgPT4gbGVhdmUuaWQgIT09IGV4Y2x1ZGVJZClcbiAgICAuc29tZShsZWF2ZSA9PiB7XG4gICAgICBjb25zdCBsZWF2ZVN0YXJ0ID0gbmV3IERhdGUobGVhdmUuc3RhcnREYXRlKTtcbiAgICAgIGNvbnN0IGxlYXZlRW5kID0gbmV3IERhdGUobGVhdmUuZW5kRGF0ZSk7XG4gICAgICBcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChpc0FmdGVyKHN0YXJ0LCBsZWF2ZVN0YXJ0KSAmJiBpc0JlZm9yZShzdGFydCwgbGVhdmVFbmQpKSB8fFxuICAgICAgICAoaXNBZnRlcihlbmQsIGxlYXZlU3RhcnQpICYmIGlzQmVmb3JlKGVuZCwgbGVhdmVFbmQpKSB8fFxuICAgICAgICAoaXNCZWZvcmUoc3RhcnQsIGxlYXZlU3RhcnQpICYmIGlzQWZ0ZXIoZW5kLCBsZWF2ZUVuZCkpIHx8XG4gICAgICAgIGlzU2FtZURheShzdGFydCwgbGVhdmVTdGFydCkgfHxcbiAgICAgICAgaXNTYW1lRGF5KGVuZCwgbGVhdmVFbmQpXG4gICAgICApO1xuICAgIH0pO1xuXG4gIGlmIChvdmVybGFwcGluZykge1xuICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogJ0NldHRlIHDDqXJpb2RlIGNoZXZhdWNoZSB1biBjb25nw6kgZXhpc3RhbnQnIH07XG4gIH1cblxuICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG59XG5cbi8qKlxuICogQ2FsY3VsZSBsZXMgc3RhdGlzdGlxdWVzIGRlcyBjb25nw6lzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVMZWF2ZVN0YXRzKGxlYXZlczogTGVhdmVFbnRyeVtdLCB5ZWFyOiBudW1iZXIpOiB7XG4gIHRvdGFsRGF5czogbnVtYmVyO1xuICBieVR5cGU6IFJlY29yZDxMZWF2ZVR5cGUsIG51bWJlcj47XG4gIGJ5TW9udGg6IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG59IHtcbiAgY29uc3QgeWVhckxlYXZlcyA9IGxlYXZlcy5maWx0ZXIobGVhdmUgPT4gXG4gICAgbmV3IERhdGUobGVhdmUuc3RhcnREYXRlKS5nZXRGdWxsWWVhcigpID09PSB5ZWFyXG4gICk7XG5cbiAgY29uc3QgdG90YWxEYXlzID0geWVhckxlYXZlcy5yZWR1Y2UoKHRvdGFsLCBsZWF2ZSkgPT4gdG90YWwgKyBsZWF2ZS53b3JraW5nRGF5cywgMCk7XG4gIFxuICBjb25zdCBieVR5cGU6IFJlY29yZDxMZWF2ZVR5cGUsIG51bWJlcj4gPSB7XG4gICAgY3A6IDAsIHJ0dDogMCwgY2V0OiAwLCBzaWNrOiAwXG4gIH07XG4gIFxuICBjb25zdCBieU1vbnRoOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG5cbiAgeWVhckxlYXZlcy5mb3JFYWNoKGxlYXZlID0+IHtcbiAgICBieVR5cGVbbGVhdmUudHlwZV0gKz0gbGVhdmUud29ya2luZ0RheXM7XG4gICAgXG4gICAgY29uc3QgbGVhdmVTdGFydCA9IG5ldyBEYXRlKGxlYXZlLnN0YXJ0RGF0ZSk7XG4gICAgY29uc3QgbW9udGggPSBmb3JtYXQobGVhdmVTdGFydCwgJ3l5eXktTU0nKTtcbiAgICBieU1vbnRoW21vbnRoXSA9IChieU1vbnRoW21vbnRoXSB8fCAwKSArIGxlYXZlLndvcmtpbmdEYXlzO1xuICB9KTtcblxuICByZXR1cm4geyB0b3RhbERheXMsIGJ5VHlwZSwgYnlNb250aCB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRpdCB1bmUgZGF0ZSBkdSBmb3JtYXQgZnJhbsOnYWlzIChERC9NTS9ZWVlZKSB2ZXJzIGxlIGZvcm1hdCBJU08gKFlZWVktTU0tREQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmVuY2hEYXRlVG9JU08oZnJlbmNoRGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFmcmVuY2hEYXRlIHx8IGZyZW5jaERhdGUubGVuZ3RoICE9PSAxMCkgcmV0dXJuICcnXG4gIFxuICBjb25zdCBwYXJ0cyA9IGZyZW5jaERhdGUuc3BsaXQoJy8nKVxuICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSByZXR1cm4gJydcbiAgXG4gIGNvbnN0IFtkYXksIG1vbnRoLCB5ZWFyXSA9IHBhcnRzXG4gIHJldHVybiBgJHt5ZWFyfS0ke21vbnRoLnBhZFN0YXJ0KDIsICcwJyl9LSR7ZGF5LnBhZFN0YXJ0KDIsICcwJyl9YFxufVxuXG4vKipcbiAqIENvbnZlcnRpdCB1bmUgZGF0ZSBkdSBmb3JtYXQgSVNPIChZWVlZLU1NLUREKSB2ZXJzIGxlIGZvcm1hdCBmcmFuw6dhaXMgKEREL01NL1lZWVkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc29EYXRlVG9GcmVuY2goaXNvRGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFpc29EYXRlIHx8IGlzb0RhdGUubGVuZ3RoICE9PSAxMCkgcmV0dXJuICcnXG4gIFxuICBjb25zdCBwYXJ0cyA9IGlzb0RhdGUuc3BsaXQoJy0nKVxuICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSByZXR1cm4gJydcbiAgXG4gIGNvbnN0IFt5ZWFyLCBtb250aCwgZGF5XSA9IHBhcnRzXG4gIHJldHVybiBgJHtkYXl9LyR7bW9udGh9LyR7eWVhcn1gXG59XG5cbi8qKlxuICogVmFsaWRlIHVuZSBkYXRlIGF1IGZvcm1hdCBmcmFuw6dhaXMgKEREL01NL1lZWVkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRnJlbmNoRGF0ZShmcmVuY2hEYXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKCFmcmVuY2hEYXRlIHx8IGZyZW5jaERhdGUubGVuZ3RoICE9PSAxMCkgcmV0dXJuIGZhbHNlXG4gIFxuICBjb25zdCBwYXJ0cyA9IGZyZW5jaERhdGUuc3BsaXQoJy8nKVxuICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSByZXR1cm4gZmFsc2VcbiAgXG4gIGNvbnN0IFtkYXksIG1vbnRoLCB5ZWFyXSA9IHBhcnRzXG4gIGNvbnN0IGlzb0RhdGUgPSBgJHt5ZWFyfS0ke21vbnRoLnBhZFN0YXJ0KDIsICcwJyl9LSR7ZGF5LnBhZFN0YXJ0KDIsICcwJyl9YFxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoaXNvRGF0ZSlcbiAgXG4gIHJldHVybiAhaXNOYU4oZGF0ZS5nZXRUaW1lKCkpICYmIFxuICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpID49IDIwMjAgJiYgXG4gICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCkgPD0gMjAzMFxufVxuIl0sIm5hbWVzIjpbImFkZERheXMiLCJmb3JtYXQiLCJpc0FmdGVyIiwiaXNCZWZvcmUiLCJpc1NhbWVEYXkiLCJpc1dlZWtlbmQiLCJmciIsIkxFQVZFX1RZUEVTIiwiY3AiLCJsYWJlbCIsImNvbG9yIiwiaWNvbiIsInJ0dCIsImNldCIsInNpY2siLCJGUkVOQ0hfSE9MSURBWVNfMjAyNCIsImlkIiwiZGF0ZSIsIm5hbWUiLCJjb3VudHJ5IiwiRlJFTkNIX0hPTElEQVlTXzIwMjUiLCJjYWxjdWxhdGVXb3JraW5nRGF5cyIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJob2xpZGF5cyIsImlzSGFsZkRheSIsImhhbGZEYXlUeXBlIiwic3RhcnQiLCJEYXRlIiwiZW5kIiwiaXNOYU4iLCJnZXRUaW1lIiwiY29uc29sZSIsImVycm9yIiwid29ya2luZ0RheXMiLCJjdXJyZW50RGF0ZSIsImlzSG9saWRheSIsInNvbWUiLCJob2xpZGF5IiwiaG9saWRheURhdGUiLCJkYXRlU3RyIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImhvbGlkYXlTdHIiLCJnZXRIb2xpZGF5c0ZvclllYXIiLCJ5ZWFyIiwiY2FsY3VsYXRlTGVhdmVCYWxhbmNlcyIsImxlYXZlcyIsInF1b3RhcyIsImNhcnJ5b3ZlcnMiLCJnZXRGdWxsWWVhciIsImJhbGFuY2VzIiwiZm9yRWFjaCIsInF1b3RhIiwieWVhckxlYXZlcyIsImZpbHRlciIsImxlYXZlIiwidHlwZSIsInVzZWQiLCJyZWR1Y2UiLCJ0b3RhbCIsImNhcnJ5b3ZlckRheXMiLCJjYXJyeW92ZXIiLCJkYXlzIiwidG90YWxXaXRoQ2FycnlvdmVyIiwieWVhcmx5UXVvdGEiLCJyZW1haW5pbmciLCJNYXRoIiwibWF4IiwicHVzaCIsImNhbGN1bGF0ZUF2YWlsYWJsZUNhcnJ5b3ZlciIsImF2YWlsYWJsZSIsImdlbmVyYXRlQ2FycnlvdmVyU3VtbWFyeSIsImJ5WWVhciIsImJ5VHlwZSIsInRvdGFsQnlUeXBlIiwiY2FuVGFrZVJUVEZvck1vbnRoIiwidGFyZ2V0TW9udGgiLCJ0YXJnZXRZZWFyIiwiY3VycmVudE1vbnRoIiwiZ2V0TW9udGgiLCJjdXJyZW50WWVhciIsImNhblRha2UiLCJyZWFzb24iLCJhdmFpbGFibGVEYXlzIiwiY2FsY3VsYXRlQXZhaWxhYmxlUlRURm9yUGVyaW9kIiwiZGV0YWlscyIsInRvdGFsQXZhaWxhYmxlIiwiY3VycmVudCIsIm1vbnRoIiwidmFsaWRhdGlvbiIsInNldE1vbnRoIiwiY2FsY3VsYXRlQ3VycmVudEF2YWlsYWJsZVJUVCIsImNhbGN1bGF0ZU1vbnRobHlMZWF2ZVN1bW1hcnlTZXBhcmF0ZWQiLCJtb250aHMiLCJtb250aE5hbWVzIiwicnR0UXVvdGEiLCJmaW5kIiwicSIsImNwUXVvdGEiLCJjZXRRdW90YSIsInRvdGFsQ1BDRVRRdW90YSIsInJ0dENhcnJ5b3ZlciIsImMiLCJjcENhcnJ5b3ZlciIsImNldENhcnJ5b3ZlciIsInRvdGFsQ1BDRVRDYXJyeW92ZXIiLCJtb250aE5hbWUiLCJyZWFsIiwidGFrZW4iLCJjdW11bCIsImZvcmVjYXN0IiwicnR0Q3VtdWxSZWFsIiwicnR0Q3VtdWxGb3JlY2FzdCIsImNwQ3VtdWxSZWFsIiwiY3BDdW11bEZvcmVjYXN0IiwibW9udGhMZWF2ZXMiLCJsZWF2ZURhdGUiLCJpc01vbnRoUGFzc2VkIiwiaXNDdXJyZW50TW9udGgiLCJydHRSZWFsIiwiaXNGb3JlY2FzdCIsInN1bSIsImNwUmVhbCIsInJ0dEZvcmVjYXN0IiwiY3BGb3JlY2FzdCIsInJ0dFJlbWFpbmluZ1JlYWwiLCJydHRSZW1haW5pbmdGb3JlY2FzdCIsImNwUmVtYWluaW5nUmVhbCIsImNwUmVtYWluaW5nRm9yZWNhc3QiLCJ5ZWFybHlUb3RhbHMiLCJpc1NhbWVQZXJpb2QiLCJmb3JlY2FzdFN0YXJ0IiwiZm9yZWNhc3RFbmQiLCJyZWFsU3RhcnQiLCJyZWFsRW5kIiwiZ2VuZXJhdGVDYWxlbmRhckRheXMiLCJsIiwibGVhdmVTdGFydCIsImxlYXZlRW5kIiwiaCIsImlzTGVhdmUiLCJsZWF2ZVR5cGUiLCJob2xpZGF5TmFtZSIsImZvcm1hdERhdGUiLCJmb3JtYXRTdHIiLCJkYXRlT2JqIiwibG9jYWxlIiwiZ2V0TGVhdmVUeXBlTGFiZWwiLCJnZXRMZWF2ZVR5cGVDb2xvciIsImdldExlYXZlVHlwZUljb24iLCJ2YWxpZGF0ZUxlYXZlUGVyaW9kIiwiZXhpc3RpbmdMZWF2ZXMiLCJleGNsdWRlSWQiLCJpc1ZhbGlkIiwib3ZlcmxhcHBpbmciLCJjYWxjdWxhdGVMZWF2ZVN0YXRzIiwidG90YWxEYXlzIiwiYnlNb250aCIsImZyZW5jaERhdGVUb0lTTyIsImZyZW5jaERhdGUiLCJsZW5ndGgiLCJwYXJ0cyIsImRheSIsInBhZFN0YXJ0IiwiaXNvRGF0ZVRvRnJlbmNoIiwiaXNvRGF0ZSIsImlzVmFsaWRGcmVuY2hEYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/leaveUtils.ts\n"));

/***/ })

});