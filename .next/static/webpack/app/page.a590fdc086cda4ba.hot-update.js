"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/leaveUtils.ts":
/*!*********************************!*\
  !*** ./src/utils/leaveUtils.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FRENCH_HOLIDAYS_2024: function() { return /* binding */ FRENCH_HOLIDAYS_2024; },\n/* harmony export */   FRENCH_HOLIDAYS_2025: function() { return /* binding */ FRENCH_HOLIDAYS_2025; },\n/* harmony export */   LEAVE_TYPES: function() { return /* binding */ LEAVE_TYPES; },\n/* harmony export */   calculateAvailableCarryover: function() { return /* binding */ calculateAvailableCarryover; },\n/* harmony export */   calculateAvailableRTTForPeriod: function() { return /* binding */ calculateAvailableRTTForPeriod; },\n/* harmony export */   calculateCurrentAvailableRTT: function() { return /* binding */ calculateCurrentAvailableRTT; },\n/* harmony export */   calculateLeaveBalances: function() { return /* binding */ calculateLeaveBalances; },\n/* harmony export */   calculateLeaveStats: function() { return /* binding */ calculateLeaveStats; },\n/* harmony export */   calculateMonthlyLeaveSummarySeparated: function() { return /* binding */ calculateMonthlyLeaveSummarySeparated; },\n/* harmony export */   calculateWorkingDays: function() { return /* binding */ calculateWorkingDays; },\n/* harmony export */   canTakeRTTForMonth: function() { return /* binding */ canTakeRTTForMonth; },\n/* harmony export */   formatDate: function() { return /* binding */ formatDate; },\n/* harmony export */   frenchDateToISO: function() { return /* binding */ frenchDateToISO; },\n/* harmony export */   generateCalendarDays: function() { return /* binding */ generateCalendarDays; },\n/* harmony export */   generateCarryoverSummary: function() { return /* binding */ generateCarryoverSummary; },\n/* harmony export */   getHolidaysForYear: function() { return /* binding */ getHolidaysForYear; },\n/* harmony export */   getLeaveTypeColor: function() { return /* binding */ getLeaveTypeColor; },\n/* harmony export */   getLeaveTypeIcon: function() { return /* binding */ getLeaveTypeIcon; },\n/* harmony export */   getLeaveTypeLabel: function() { return /* binding */ getLeaveTypeLabel; },\n/* harmony export */   isHoliday: function() { return /* binding */ isHoliday; },\n/* harmony export */   isValidFrenchDate: function() { return /* binding */ isValidFrenchDate; },\n/* harmony export */   isoDateToFrench: function() { return /* binding */ isoDateToFrench; },\n/* harmony export */   validateLeavePeriod: function() { return /* binding */ validateLeavePeriod; }\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=addDays,format,isAfter,isBefore,isSameDay,isWeekend!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isAfter.js\");\n/* harmony import */ var _barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=addDays,format,isAfter,isBefore,isSameDay,isWeekend!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isWeekend.js\");\n/* harmony import */ var _barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=addDays,format,isAfter,isBefore,isSameDay,isWeekend!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/addDays.js\");\n/* harmony import */ var _barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=addDays,format,isAfter,isBefore,isSameDay,isWeekend!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isSameDay.js\");\n/* harmony import */ var _barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=addDays,format,isAfter,isBefore,isSameDay,isWeekend!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/format.js\");\n/* harmony import */ var _barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=addDays,format,isAfter,isBefore,isSameDay,isWeekend!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isBefore.js\");\n/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns/locale */ \"(app-pages-browser)/./node_modules/date-fns/locale/fr.js\");\n\n\n// Configuration des types de congés\nconst LEAVE_TYPES = {\n    cp: {\n        label: \"Cong\\xe9s Pay\\xe9s\",\n        color: \"leave-cp\",\n        icon: \"\\uD83C\\uDFD6️\"\n    },\n    rtt: {\n        label: \"RTT\",\n        color: \"leave-rtt\",\n        icon: \"\\uD83D\\uDCC5\"\n    },\n    cet: {\n        label: \"CET\",\n        color: \"leave-cet\",\n        icon: \"\\uD83C\\uDFE5\"\n    },\n    sick: {\n        label: \"Maladie\",\n        color: \"leave-sick\",\n        icon: \"\\uD83C\\uDFE5\"\n    }\n};\n// Jours fériés français 2024\nconst FRENCH_HOLIDAYS_2024 = [\n    {\n        id: \"1\",\n        date: \"2024-01-01\",\n        name: \"Jour de l'an\",\n        country: \"FR\"\n    },\n    {\n        id: \"2\",\n        date: \"2024-05-01\",\n        name: \"F\\xeate du travail\",\n        country: \"FR\"\n    },\n    {\n        id: \"3\",\n        date: \"2024-05-08\",\n        name: \"Victoire 1945\",\n        country: \"FR\"\n    },\n    {\n        id: \"4\",\n        date: \"2024-05-09\",\n        name: \"Ascension\",\n        country: \"FR\"\n    },\n    {\n        id: \"5\",\n        date: \"2024-05-20\",\n        name: \"Lundi de Pentec\\xf4te\",\n        country: \"FR\"\n    },\n    {\n        id: \"6\",\n        date: \"2024-07-14\",\n        name: \"F\\xeate nationale\",\n        country: \"FR\"\n    },\n    {\n        id: \"7\",\n        date: \"2024-08-15\",\n        name: \"Assomption\",\n        country: \"FR\"\n    },\n    {\n        id: \"8\",\n        date: \"2024-11-01\",\n        name: \"Toussaint\",\n        country: \"FR\"\n    },\n    {\n        id: \"9\",\n        date: \"2024-11-11\",\n        name: \"Armistice\",\n        country: \"FR\"\n    },\n    {\n        id: \"10\",\n        date: \"2024-12-25\",\n        name: \"No\\xebl\",\n        country: \"FR\"\n    }\n];\n// Jours fériés français 2025\nconst FRENCH_HOLIDAYS_2025 = [\n    {\n        id: \"1\",\n        date: \"2025-01-01\",\n        name: \"Jour de l'an\",\n        country: \"FR\"\n    },\n    {\n        id: \"2\",\n        date: \"2025-05-01\",\n        name: \"F\\xeate du travail\",\n        country: \"FR\"\n    },\n    {\n        id: \"3\",\n        date: \"2025-05-08\",\n        name: \"Victoire 1945\",\n        country: \"FR\"\n    },\n    {\n        id: \"4\",\n        date: \"2025-05-29\",\n        name: \"Ascension\",\n        country: \"FR\"\n    },\n    {\n        id: \"5\",\n        date: \"2025-06-09\",\n        name: \"Lundi de Pentec\\xf4te\",\n        country: \"FR\"\n    },\n    {\n        id: \"6\",\n        date: \"2025-07-14\",\n        name: \"F\\xeate nationale\",\n        country: \"FR\"\n    },\n    {\n        id: \"7\",\n        date: \"2025-08-15\",\n        name: \"Assomption\",\n        country: \"FR\"\n    },\n    {\n        id: \"8\",\n        date: \"2025-11-01\",\n        name: \"Toussaint\",\n        country: \"FR\"\n    },\n    {\n        id: \"9\",\n        date: \"2025-11-11\",\n        name: \"Armistice\",\n        country: \"FR\"\n    },\n    {\n        id: \"10\",\n        date: \"2025-12-25\",\n        name: \"No\\xebl\",\n        country: \"FR\"\n    }\n];\n/**\n * Calcule le nombre de jours ouvrés entre deux dates\n */ function calculateWorkingDays(startDate, endDate) {\n    let holidays = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], isHalfDay = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, halfDayType = arguments.length > 4 ? arguments[4] : void 0;\n    // Parse dates safely using new Date() instead of parseISO\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    // Validate dates\n    if (isNaN(start.getTime()) || isNaN(end.getTime())) {\n        console.error(\"Invalid date input:\", {\n            startDate,\n            endDate\n        });\n        return 0;\n    }\n    let workingDays = 0;\n    let currentDate = start;\n    while(!(0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__.isAfter)(currentDate, end)){\n        if (!(0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_1__.isWeekend)(currentDate) && !isHoliday(currentDate, holidays)) {\n            workingDays++;\n        }\n        currentDate = (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_2__.addDays)(currentDate, 1);\n    }\n    // Si c'est un demi-jour, ajuster le calcul\n    if (isHalfDay && workingDays > 0) {\n        // Si c'est le même jour (début = fin), c'est 0.5 jour\n        if ((0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__.isSameDay)(start, end)) {\n            workingDays = 0.5;\n        } else {\n        // Pour les périodes de plusieurs jours, on peut ajuster selon le type de demi-jour\n        // Par défaut, on garde le calcul normal car les demi-jours sont généralement\n        // appliqués au premier ou dernier jour selon le contexte\n        }\n    }\n    return workingDays;\n}\n/**\n * Vérifie si une date est un jour férié\n */ function isHoliday(date, holidays) {\n    return holidays.some((holiday)=>{\n        const holidayDate = new Date(holiday.date);\n        // Comparer les dates en format YYYY-MM-DD pour éviter les problèmes de timezone\n        const dateStr = date.toISOString().split(\"T\")[0];\n        const holidayStr = holidayDate.toISOString().split(\"T\")[0];\n        return dateStr === holidayStr;\n    });\n}\n/**\n * Obtient les jours fériés pour une année donnée\n */ function getHolidaysForYear(year) {\n    if (year === 2024) return FRENCH_HOLIDAYS_2024;\n    if (year === 2025) return FRENCH_HOLIDAYS_2025;\n    // Pour les autres années, on peut étendre ou utiliser une API\n    return [];\n}\n/**\n * Calcule le solde de congés pour chaque type en incluant les reliquats\n */ function calculateLeaveBalances(leaves, quotas) {\n    let carryovers = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], year = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new Date().getFullYear();\n    const balances = [];\n    quotas.forEach((quota)=>{\n        const yearLeaves = leaves.filter((leave)=>leave.type === quota.type && new Date(leave.startDate).getFullYear() === year);\n        const used = yearLeaves.reduce((total, leave)=>total + leave.workingDays, 0);\n        // Calculer les reliquats pour ce type de congé\n        const carryoverDays = carryovers.filter((carryover)=>carryover.type === quota.type).reduce((total, carryover)=>total + carryover.days, 0);\n        // Le total inclut le quota annuel + les reliquats\n        const totalWithCarryover = quota.yearlyQuota + carryoverDays;\n        const remaining = Math.max(0, totalWithCarryover - used);\n        balances.push({\n            type: quota.type,\n            total: totalWithCarryover,\n            used,\n            remaining,\n            carryover: carryoverDays\n        });\n    });\n    return balances;\n}\n/**\n * Calcule les reliquats disponibles pour une année donnée\n */ function calculateAvailableCarryover(carryovers) {\n    let year = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Date().getFullYear();\n    const available = {\n        cp: 0,\n        rtt: 0,\n        cet: 0,\n        sick: 0\n    };\n    carryovers.forEach((carryover)=>{\n        available[carryover.type] += carryover.days;\n    });\n    return available;\n}\n/**\n * Génère un résumé des reliquats par année\n */ function generateCarryoverSummary(carryovers) {\n    const byYear = {};\n    const byType = {\n        cp: [],\n        rtt: [],\n        cet: [],\n        sick: []\n    };\n    const totalByType = {\n        cp: 0,\n        rtt: 0,\n        cet: 0,\n        sick: 0\n    };\n    carryovers.forEach((carryover)=>{\n        // Par année\n        if (!byYear[carryover.year]) {\n            byYear[carryover.year] = [];\n        }\n        byYear[carryover.year].push(carryover);\n        // Par type\n        byType[carryover.type].push(carryover);\n        totalByType[carryover.type] += carryover.days;\n    });\n    return {\n        byYear,\n        byType,\n        totalByType\n    };\n}\n/**\n * Valide si les RTT peuvent être pris pour un mois donné\n * Les RTT s'accumulent à la fin du mois, donc on ne peut les prendre\n * que si le mois correspondant est passé\n */ function canTakeRTTForMonth(targetMonth, targetYear) {\n    let currentDate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Date();\n    const currentMonth = currentDate.getMonth() + 1; // 1-12\n    const currentYear = currentDate.getFullYear();\n    // Si on est dans une année future, on ne peut pas encore prendre les RTT\n    if (targetYear > currentYear) {\n        return {\n            canTake: false,\n            reason: \"Les RTT de \".concat(targetYear, \" ne sont pas encore disponibles\"),\n            availableDays: 0\n        };\n    }\n    // Si on est dans une année passée, on peut prendre les RTT\n    if (targetYear < currentYear) {\n        return {\n            canTake: true,\n            availableDays: 2 // 2 RTT par mois\n        };\n    }\n    // Même année : vérifier si le mois est passé\n    if (targetMonth < currentMonth) {\n        return {\n            canTake: true,\n            availableDays: 2\n        };\n    } else if (targetMonth === currentMonth) {\n        // Pour le mois en cours, on peut prendre les RTT dès le début du mois\n        return {\n            canTake: true,\n            availableDays: 2\n        };\n    } else {\n        // Mois futur\n        return {\n            canTake: false,\n            reason: \"Les RTT de ce mois ne sont pas encore disponibles\",\n            availableDays: 0\n        };\n    }\n}\n/**\n * Calcule le nombre total de RTT disponibles pour une période donnée\n */ function calculateAvailableRTTForPeriod(startDate, endDate) {\n    let currentDate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Date();\n    const details = [];\n    let totalAvailable = 0;\n    const current = new Date(startDate);\n    while(current <= endDate){\n        const month = current.getMonth() + 1;\n        const year = current.getFullYear();\n        const validation = canTakeRTTForMonth(month, year, currentDate);\n        details.push({\n            month,\n            year,\n            available: validation.availableDays,\n            canTake: validation.canTake\n        });\n        if (validation.canTake) {\n            totalAvailable += validation.availableDays;\n        }\n        // Passer au mois suivant\n        current.setMonth(current.getMonth() + 1);\n    }\n    return {\n        totalAvailable,\n        details\n    };\n}\n/**\n * Calcule le nombre total de RTT disponibles actuellement\n * (depuis le début de l'année jusqu'à maintenant)\n */ function calculateCurrentAvailableRTT() {\n    let currentDate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Date(), year = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : currentDate.getFullYear();\n    const details = [];\n    let totalAvailable = 0;\n    // Parcourir tous les mois de l'année jusqu'au mois actuel\n    for(let month = 1; month <= 12; month++){\n        const validation = canTakeRTTForMonth(month, year, currentDate);\n        details.push({\n            month,\n            available: validation.availableDays,\n            canTake: validation.canTake,\n            reason: validation.reason\n        });\n        if (validation.canTake) {\n            totalAvailable += validation.availableDays;\n        }\n    }\n    return {\n        totalAvailable,\n        details\n    };\n}\n// Nouvelle fonction pour calculer les données séparées par type (réel vs prévision)\nfunction calculateMonthlyLeaveSummarySeparated(leaves, quotas) {\n    let carryovers = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], year = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new Date().getFullYear();\n    var _quotas_find, _quotas_find1, _quotas_find2, _carryovers_find, _carryovers_find1, _carryovers_find2;\n    const months = [];\n    const monthNames = [\n        \"Janvier\",\n        \"F\\xe9vrier\",\n        \"Mars\",\n        \"Avril\",\n        \"Mai\",\n        \"Juin\",\n        \"Juillet\",\n        \"Ao\\xfbt\",\n        \"Septembre\",\n        \"Octobre\",\n        \"Novembre\",\n        \"D\\xe9cembre\"\n    ];\n    const currentDate = new Date();\n    const currentMonth = currentDate.getMonth() + 1; // 1-12\n    const currentYear = currentDate.getFullYear();\n    // Récupérer les quotas\n    const rttQuota = ((_quotas_find = quotas.find((q)=>q.type === \"rtt\")) === null || _quotas_find === void 0 ? void 0 : _quotas_find.yearlyQuota) || 23;\n    const cpQuota = ((_quotas_find1 = quotas.find((q)=>q.type === \"cp\")) === null || _quotas_find1 === void 0 ? void 0 : _quotas_find1.yearlyQuota) || 25;\n    const cetQuota = ((_quotas_find2 = quotas.find((q)=>q.type === \"cet\")) === null || _quotas_find2 === void 0 ? void 0 : _quotas_find2.yearlyQuota) || 5;\n    const totalCPCETQuota = cpQuota + cetQuota;\n    // Récupérer les reliquats\n    const rttCarryover = ((_carryovers_find = carryovers.find((c)=>c.type === \"rtt\")) === null || _carryovers_find === void 0 ? void 0 : _carryovers_find.days) || 0;\n    const cpCarryover = ((_carryovers_find1 = carryovers.find((c)=>c.type === \"cp\")) === null || _carryovers_find1 === void 0 ? void 0 : _carryovers_find1.days) || 0;\n    const cetCarryover = ((_carryovers_find2 = carryovers.find((c)=>c.type === \"cet\")) === null || _carryovers_find2 === void 0 ? void 0 : _carryovers_find2.days) || 0;\n    const totalCPCETCarryover = cpCarryover + cetCarryover;\n    let rttCumulReal = 0;\n    let rttCumulForecast = 0;\n    let cpCumulReal = 0;\n    let cpCumulForecast = 0;\n    for(let month = 1; month <= 12; month++){\n        // Filtrer les congés pour ce mois et cette année\n        const monthLeaves = leaves.filter((leave)=>{\n            const leaveDate = new Date(leave.startDate);\n            return leaveDate.getFullYear() === year && leaveDate.getMonth() === month - 1;\n        });\n        // Séparer les congés réels et les prévisions\n        // Si le mois est passé, les prévisions deviennent réelles\n        const isMonthPassed = year < currentYear || year === currentYear && month < currentMonth;\n        const isCurrentMonth = year === currentYear && month === currentMonth;\n        // Congés réels : tous les congés non marqués comme prévision OU les prévisions des mois passés\n        const rttReal = monthLeaves.filter((leave)=>leave.type === \"rtt\" && (!leave.isForecast || isMonthPassed)).reduce((sum, leave)=>sum + leave.workingDays, 0);\n        const cpReal = monthLeaves.filter((leave)=>leave.type === \"cp\" && (!leave.isForecast || isMonthPassed)).reduce((sum, leave)=>sum + leave.workingDays, 0);\n        // Pour les prévisions, compter les congés marqués comme prévision des mois futurs\n        // ET les congés non marqués comme prévision des mois futurs (pour simulation)\n        const rttForecast = monthLeaves.filter((leave)=>leave.type === \"rtt\" && (leave.isForecast || !isMonthPassed && !isCurrentMonth)).reduce((sum, leave)=>sum + leave.workingDays, 0);\n        const cpForecast = monthLeaves.filter((leave)=>leave.type === \"cp\" && (leave.isForecast || !isMonthPassed && !isCurrentMonth)).reduce((sum, leave)=>sum + leave.workingDays, 0);\n        // Calculer les cumuls\n        rttCumulReal += rttReal;\n        rttCumulForecast += rttForecast;\n        cpCumulReal += cpReal;\n        cpCumulForecast += cpForecast;\n        // Calculer les soldes restants (cumuls inversés)\n        const rttRemainingReal = Math.max(0, rttQuota + rttCarryover - rttCumulReal);\n        const rttRemainingForecast = Math.max(0, rttQuota + rttCarryover - rttCumulReal - rttCumulForecast);\n        const cpRemainingReal = Math.max(0, totalCPCETQuota + totalCPCETCarryover - cpCumulReal);\n        const cpRemainingForecast = Math.max(0, totalCPCETQuota + totalCPCETCarryover - cpCumulReal - cpCumulForecast);\n        months.push({\n            month,\n            monthName: monthNames[month - 1],\n            rtt: {\n                real: {\n                    taken: rttReal,\n                    cumul: rttCumulReal,\n                    remaining: rttRemainingReal\n                },\n                forecast: {\n                    taken: rttForecast,\n                    cumul: rttCumulForecast,\n                    remaining: rttRemainingForecast\n                }\n            },\n            cp: {\n                real: {\n                    taken: cpReal,\n                    cumul: cpCumulReal,\n                    remaining: cpRemainingReal\n                },\n                forecast: {\n                    taken: cpForecast,\n                    cumul: cpCumulForecast,\n                    remaining: cpRemainingForecast\n                }\n            }\n        });\n    }\n    return {\n        months,\n        yearlyTotals: {\n            rtt: {\n                real: rttCumulReal,\n                forecast: rttCumulForecast,\n                total: rttCumulReal + rttCumulForecast\n            },\n            cp: {\n                real: cpCumulReal,\n                forecast: cpCumulForecast,\n                total: cpCumulReal + cpCumulForecast\n            }\n        }\n    };\n}\n// Fonction utilitaire pour vérifier si deux congés correspondent à la même période\nfunction isSamePeriod(forecast, real) {\n    // Si c'est un seul jour, vérifier la date exacte\n    if (forecast.workingDays === 1 && real.workingDays === 1) {\n        return forecast.startDate === real.startDate;\n    }\n    // Si c'est une période, vérifier si les dates se chevauchent\n    const forecastStart = new Date(forecast.startDate);\n    const forecastEnd = new Date(forecast.endDate);\n    const realStart = new Date(real.startDate);\n    const realEnd = new Date(real.endDate);\n    // Vérifier si les périodes se chevauchent\n    return forecastStart <= realEnd && realStart <= forecastEnd;\n}\n/**\n * Génère les données du calendrier pour un mois donné\n */ function generateCalendarDays(year, month, leaves, holidays) {\n    const days = [];\n    const startDate = new Date(year, month - 1, 1);\n    const endDate = new Date(year, month, 0);\n    let currentDate = startDate;\n    while(currentDate <= endDate){\n        const dateStr = (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(currentDate, \"yyyy-MM-dd\");\n        const leave = leaves.find((l)=>{\n            const leaveStart = new Date(l.startDate);\n            const leaveEnd = new Date(l.endDate);\n            return (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__.isSameDay)(currentDate, leaveStart) || (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__.isSameDay)(currentDate, leaveEnd) || (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__.isAfter)(currentDate, leaveStart) && (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_5__.isBefore)(currentDate, leaveEnd);\n        });\n        const holiday = holidays.find((h)=>{\n            const holidayDate = new Date(h.date);\n            return (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__.isSameDay)(currentDate, holidayDate);\n        });\n        days.push({\n            date: dateStr,\n            isLeave: !!leave,\n            leaveType: leave === null || leave === void 0 ? void 0 : leave.type,\n            isWeekend: (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_1__.isWeekend)(currentDate),\n            isHoliday: !!holiday,\n            holidayName: holiday === null || holiday === void 0 ? void 0 : holiday.name\n        });\n        currentDate = (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_2__.addDays)(currentDate, 1);\n    }\n    return days;\n}\n/**\n * Formate une date pour l'affichage\n */ function formatDate(date) {\n    let formatStr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"dd/MM/yyyy\";\n    const dateObj = typeof date === \"string\" ? new Date(date) : date;\n    // Validate the date\n    if (isNaN(dateObj.getTime())) {\n        console.error(\"Invalid date for formatting:\", date);\n        return \"Date invalide\";\n    }\n    return (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(dateObj, formatStr, {\n        locale: date_fns_locale__WEBPACK_IMPORTED_MODULE_6__.fr\n    });\n}\n/**\n * Obtient le nom du type de congé\n */ function getLeaveTypeLabel(type) {\n    return LEAVE_TYPES[type].label;\n}\n/**\n * Obtient la couleur du type de congé\n */ function getLeaveTypeColor(type) {\n    return LEAVE_TYPES[type].color;\n}\n/**\n * Obtient l'icône du type de congé\n */ function getLeaveTypeIcon(type) {\n    return LEAVE_TYPES[type].icon;\n}\n/**\n * Valide une période de congés\n */ function validateLeavePeriod(startDate, endDate, existingLeaves, excludeId) {\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    if ((0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__.isAfter)(start, end)) {\n        return {\n            isValid: false,\n            error: \"La date de d\\xe9but doit \\xeatre ant\\xe9rieure \\xe0 la date de fin\"\n        };\n    }\n    // Vérifier les chevauchements avec les congés existants\n    const overlapping = existingLeaves.filter((leave)=>leave.id !== excludeId).some((leave)=>{\n        const leaveStart = new Date(leave.startDate);\n        const leaveEnd = new Date(leave.endDate);\n        return (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__.isAfter)(start, leaveStart) && (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_5__.isBefore)(start, leaveEnd) || (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__.isAfter)(end, leaveStart) && (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_5__.isBefore)(end, leaveEnd) || (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_5__.isBefore)(start, leaveStart) && (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_0__.isAfter)(end, leaveEnd) || (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__.isSameDay)(start, leaveStart) || (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_3__.isSameDay)(end, leaveEnd);\n    });\n    if (overlapping) {\n        return {\n            isValid: false,\n            error: \"Cette p\\xe9riode chevauche un cong\\xe9 existant\"\n        };\n    }\n    return {\n        isValid: true\n    };\n}\n/**\n * Calcule les statistiques des congés\n */ function calculateLeaveStats(leaves, year) {\n    const yearLeaves = leaves.filter((leave)=>new Date(leave.startDate).getFullYear() === year);\n    const totalDays = yearLeaves.reduce((total, leave)=>total + leave.workingDays, 0);\n    const byType = {\n        cp: 0,\n        rtt: 0,\n        cet: 0,\n        sick: 0\n    };\n    const byMonth = {};\n    yearLeaves.forEach((leave)=>{\n        byType[leave.type] += leave.workingDays;\n        const leaveStart = new Date(leave.startDate);\n        const month = (0,_barrel_optimize_names_addDays_format_isAfter_isBefore_isSameDay_isWeekend_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(leaveStart, \"yyyy-MM\");\n        byMonth[month] = (byMonth[month] || 0) + leave.workingDays;\n    });\n    return {\n        totalDays,\n        byType,\n        byMonth\n    };\n}\n/**\n * Convertit une date du format français (DD/MM/YYYY) vers le format ISO (YYYY-MM-DD)\n */ function frenchDateToISO(frenchDate) {\n    if (!frenchDate || frenchDate.length !== 10) return \"\";\n    const parts = frenchDate.split(\"/\");\n    if (parts.length !== 3) return \"\";\n    const [day, month, year] = parts;\n    return \"\".concat(year, \"-\").concat(month.padStart(2, \"0\"), \"-\").concat(day.padStart(2, \"0\"));\n}\n/**\n * Convertit une date du format ISO (YYYY-MM-DD) vers le format français (DD/MM/YYYY)\n */ function isoDateToFrench(isoDate) {\n    if (!isoDate || isoDate.length !== 10) return \"\";\n    const parts = isoDate.split(\"-\");\n    if (parts.length !== 3) return \"\";\n    const [year, month, day] = parts;\n    return \"\".concat(day, \"/\").concat(month, \"/\").concat(year);\n}\n/**\n * Valide une date au format français (DD/MM/YYYY)\n */ function isValidFrenchDate(frenchDate) {\n    if (!frenchDate || frenchDate.length !== 10) return false;\n    const parts = frenchDate.split(\"/\");\n    if (parts.length !== 3) return false;\n    const [day, month, year] = parts;\n    const isoDate = \"\".concat(year, \"-\").concat(month.padStart(2, \"0\"), \"-\").concat(day.padStart(2, \"0\"));\n    const date = new Date(isoDate);\n    return !isNaN(date.getTime()) && date.getFullYear() >= 2020 && date.getFullYear() <= 2030;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9sZWF2ZVV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRjtBQUMvQztBQUdyQyxvQ0FBb0M7QUFDN0IsTUFBTU8sY0FBYztJQUN6QkMsSUFBSTtRQUFFQyxPQUFPO1FBQWdCQyxPQUFPO1FBQVlDLE1BQU07SUFBTTtJQUM1REMsS0FBSztRQUFFSCxPQUFPO1FBQU9DLE9BQU87UUFBYUMsTUFBTTtJQUFLO0lBQ3BERSxLQUFLO1FBQUVKLE9BQU87UUFBT0MsT0FBTztRQUFhQyxNQUFNO0lBQUs7SUFDcERHLE1BQU07UUFBRUwsT0FBTztRQUFXQyxPQUFPO1FBQWNDLE1BQU07SUFBSztBQUM1RCxFQUFXO0FBRVgsNkJBQTZCO0FBQ3RCLE1BQU1JLHVCQUF3QztJQUNuRDtRQUFFQyxJQUFJO1FBQUtDLE1BQU07UUFBY0MsTUFBTTtRQUFpQkMsU0FBUztJQUFLO0lBQ3BFO1FBQUVILElBQUk7UUFBS0MsTUFBTTtRQUFjQyxNQUFNO1FBQW1CQyxTQUFTO0lBQUs7SUFDdEU7UUFBRUgsSUFBSTtRQUFLQyxNQUFNO1FBQWNDLE1BQU07UUFBaUJDLFNBQVM7SUFBSztJQUNwRTtRQUFFSCxJQUFJO1FBQUtDLE1BQU07UUFBY0MsTUFBTTtRQUFhQyxTQUFTO0lBQUs7SUFDaEU7UUFBRUgsSUFBSTtRQUFLQyxNQUFNO1FBQWNDLE1BQU07UUFBc0JDLFNBQVM7SUFBSztJQUN6RTtRQUFFSCxJQUFJO1FBQUtDLE1BQU07UUFBY0MsTUFBTTtRQUFrQkMsU0FBUztJQUFLO0lBQ3JFO1FBQUVILElBQUk7UUFBS0MsTUFBTTtRQUFjQyxNQUFNO1FBQWNDLFNBQVM7SUFBSztJQUNqRTtRQUFFSCxJQUFJO1FBQUtDLE1BQU07UUFBY0MsTUFBTTtRQUFhQyxTQUFTO0lBQUs7SUFDaEU7UUFBRUgsSUFBSTtRQUFLQyxNQUFNO1FBQWNDLE1BQU07UUFBYUMsU0FBUztJQUFLO0lB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LEtBQVl0SCxPQUFUNEMsT0FBTSxLQUFRLE9BQUw1QztBQUM1QjtBQUVBOztDQUVDLEdBQ00sU0FBUzBILGtCQUFrQlAsVUFBa0I7SUFDbEQsSUFBSSxDQUFDQSxjQUFjQSxXQUFXQyxNQUFNLEtBQUssSUFBSSxPQUFPO0lBRXBELE1BQU1DLFFBQVFGLFdBQVd0SCxLQUFLLENBQUM7SUFDL0IsSUFBSXdILE1BQU1ELE1BQU0sS0FBSyxHQUFHLE9BQU87SUFFL0IsTUFBTSxDQUFDRSxLQUFLMUUsT0FBTzVDLEtBQUssR0FBR3FIO0lBQzNCLE1BQU1JLFVBQVUsR0FBVzdFLE9BQVI1QyxNQUFLLEtBQTZCc0gsT0FBMUIxRSxNQUFNMkUsUUFBUSxDQUFDLEdBQUcsTUFBSyxLQUF3QixPQUFyQkQsSUFBSUMsUUFBUSxDQUFDLEdBQUc7SUFDckUsTUFBTW5KLE9BQU8sSUFBSVcsS0FBSzBJO0lBRXRCLE9BQU8sQ0FBQ3hJLE1BQU1iLEtBQUtjLE9BQU8sT0FDbkJkLEtBQUtpQyxXQUFXLE1BQU0sUUFDdEJqQyxLQUFLaUMsV0FBVyxNQUFNO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9sZWF2ZVV0aWxzLnRzP2I3YzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWRkRGF5cywgZm9ybWF0LCBpc0FmdGVyLCBpc0JlZm9yZSwgaXNTYW1lRGF5LCBpc1dlZWtlbmQgfSBmcm9tICdkYXRlLWZucyc7XG5pbXBvcnQgeyBmciB9IGZyb20gJ2RhdGUtZm5zL2xvY2FsZSc7XG5pbXBvcnQgeyBDYWxlbmRhckRheSwgQ2FycnlvdmVyTGVhdmUsIExlYXZlQmFsYW5jZSwgTGVhdmVFbnRyeSwgTGVhdmVUeXBlLCBQdWJsaWNIb2xpZGF5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vLyBDb25maWd1cmF0aW9uIGRlcyB0eXBlcyBkZSBjb25nw6lzXG5leHBvcnQgY29uc3QgTEVBVkVfVFlQRVMgPSB7XG4gIGNwOiB7IGxhYmVsOiAnQ29uZ8OpcyBQYXnDqXMnLCBjb2xvcjogJ2xlYXZlLWNwJywgaWNvbjogJ/Cfj5bvuI8nIH0sXG4gIHJ0dDogeyBsYWJlbDogJ1JUVCcsIGNvbG9yOiAnbGVhdmUtcnR0JywgaWNvbjogJ/Cfk4UnIH0sXG4gIGNldDogeyBsYWJlbDogJ0NFVCcsIGNvbG9yOiAnbGVhdmUtY2V0JywgaWNvbjogJ/Cfj6UnIH0sXG4gIHNpY2s6IHsgbGFiZWw6ICdNYWxhZGllJywgY29sb3I6ICdsZWF2ZS1zaWNrJywgaWNvbjogJ/Cfj6UnIH0sXG59IGFzIGNvbnN0O1xuXG4vLyBKb3VycyBmw6lyacOpcyBmcmFuw6dhaXMgMjAyNFxuZXhwb3J0IGNvbnN0IEZSRU5DSF9IT0xJREFZU18yMDI0OiBQdWJsaWNIb2xpZGF5W10gPSBbXG4gIHsgaWQ6ICcxJywgZGF0ZTogJzIwMjQtMDEtMDEnLCBuYW1lOiAnSm91ciBkZSBsXFwnYW4nLCBjb3VudHJ5OiAnRlInIH0sXG4gIHsgaWQ6ICcyJywgZGF0ZTogJzIwMjQtMDUtMDEnLCBuYW1lOiAnRsOqdGUgZHUgdHJhdmFpbCcsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzMnLCBkYXRlOiAnMjAyNC0wNS0wOCcsIG5hbWU6ICdWaWN0b2lyZSAxOTQ1JywgY291bnRyeTogJ0ZSJyB9LFxuICB7IGlkOiAnNCcsIGRhdGU6ICcyMDI0LTA1LTA5JywgbmFtZTogJ0FzY2Vuc2lvbicsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzUnLCBkYXRlOiAnMjAyNC0wNS0yMCcsIG5hbWU6ICdMdW5kaSBkZSBQZW50ZWPDtHRlJywgY291bnRyeTogJ0ZSJyB9LFxuICB7IGlkOiAnNicsIGRhdGU6ICcyMDI0LTA3LTE0JywgbmFtZTogJ0bDqnRlIG5hdGlvbmFsZScsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzcnLCBkYXRlOiAnMjAyNC0wOC0xNScsIG5hbWU6ICdBc3NvbXB0aW9uJywgY291bnRyeTogJ0ZSJyB9LFxuICB7IGlkOiAnOCcsIGRhdGU6ICcyMDI0LTExLTAxJywgbmFtZTogJ1RvdXNzYWludCcsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzknLCBkYXRlOiAnMjAyNC0xMS0xMScsIG5hbWU6ICdBcm1pc3RpY2UnLCBjb3VudHJ5OiAnRlInIH0sXG4gIHsgaWQ6ICcxMCcsIGRhdGU6ICcyMDI0LTEyLTI1JywgbmFtZTogJ05vw6tsJywgY291bnRyeTogJ0ZSJyB9LFxuXTtcblxuLy8gSm91cnMgZsOpcmnDqXMgZnJhbsOnYWlzIDIwMjVcbmV4cG9ydCBjb25zdCBGUkVOQ0hfSE9MSURBWVNfMjAyNTogUHVibGljSG9saWRheVtdID0gW1xuICB7IGlkOiAnMScsIGRhdGU6ICcyMDI1LTAxLTAxJywgbmFtZTogJ0pvdXIgZGUgbFxcJ2FuJywgY291bnRyeTogJ0ZSJyB9LFxuICB7IGlkOiAnMicsIGRhdGU6ICcyMDI1LTA1LTAxJywgbmFtZTogJ0bDqnRlIGR1IHRyYXZhaWwnLCBjb3VudHJ5OiAnRlInIH0sXG4gIHsgaWQ6ICczJywgZGF0ZTogJzIwMjUtMDUtMDgnLCBuYW1lOiAnVmljdG9pcmUgMTk0NScsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzQnLCBkYXRlOiAnMjAyNS0wNS0yOScsIG5hbWU6ICdBc2NlbnNpb24nLCBjb3VudHJ5OiAnRlInIH0sXG4gIHsgaWQ6ICc1JywgZGF0ZTogJzIwMjUtMDYtMDknLCBuYW1lOiAnTHVuZGkgZGUgUGVudGVjw7R0ZScsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzYnLCBkYXRlOiAnMjAyNS0wNy0xNCcsIG5hbWU6ICdGw6p0ZSBuYXRpb25hbGUnLCBjb3VudHJ5OiAnRlInIH0sXG4gIHsgaWQ6ICc3JywgZGF0ZTogJzIwMjUtMDgtMTUnLCBuYW1lOiAnQXNzb21wdGlvbicsIGNvdW50cnk6ICdGUicgfSxcbiAgeyBpZDogJzgnLCBkYXRlOiAnMjAyNS0xMS0wMScsIG5hbWU6ICdUb3Vzc2FpbnQnLCBjb3VudHJ5OiAnRlInIH0sXG4gIHsgaWQ6ICc5JywgZGF0ZTogJzIwMjUtMTEtMTEnLCBuYW1lOiAnQXJtaXN0aWNlJywgY291bnRyeTogJ0ZSJyB9LFxuICB7IGlkOiAnMTAnLCBkYXRlOiAnMjAyNS0xMi0yNScsIG5hbWU6ICdOb8OrbCcsIGNvdW50cnk6ICdGUicgfSxcbl07XG5cbi8qKlxuICogQ2FsY3VsZSBsZSBub21icmUgZGUgam91cnMgb3V2csOpcyBlbnRyZSBkZXV4IGRhdGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVXb3JraW5nRGF5cyhcbiAgc3RhcnREYXRlOiBzdHJpbmcsIFxuICBlbmREYXRlOiBzdHJpbmcsIFxuICBob2xpZGF5czogUHVibGljSG9saWRheVtdID0gW10sXG4gIGlzSGFsZkRheTogYm9vbGVhbiA9IGZhbHNlLFxuICBoYWxmRGF5VHlwZT86ICdtb3JuaW5nJyB8ICdhZnRlcm5vb24nXG4pOiBudW1iZXIge1xuICAvLyBQYXJzZSBkYXRlcyBzYWZlbHkgdXNpbmcgbmV3IERhdGUoKSBpbnN0ZWFkIG9mIHBhcnNlSVNPXG4gIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoc3RhcnREYXRlKTtcbiAgY29uc3QgZW5kID0gbmV3IERhdGUoZW5kRGF0ZSk7XG4gIFxuICAvLyBWYWxpZGF0ZSBkYXRlc1xuICBpZiAoaXNOYU4oc3RhcnQuZ2V0VGltZSgpKSB8fCBpc05hTihlbmQuZ2V0VGltZSgpKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgZGF0ZSBpbnB1dDonLCB7IHN0YXJ0RGF0ZSwgZW5kRGF0ZSB9KTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBcbiAgbGV0IHdvcmtpbmdEYXlzID0gMDtcbiAgbGV0IGN1cnJlbnREYXRlID0gc3RhcnQ7XG5cbiAgd2hpbGUgKCFpc0FmdGVyKGN1cnJlbnREYXRlLCBlbmQpKSB7XG4gICAgaWYgKCFpc1dlZWtlbmQoY3VycmVudERhdGUpICYmICFpc0hvbGlkYXkoY3VycmVudERhdGUsIGhvbGlkYXlzKSkge1xuICAgICAgd29ya2luZ0RheXMrKztcbiAgICB9XG4gICAgY3VycmVudERhdGUgPSBhZGREYXlzKGN1cnJlbnREYXRlLCAxKTtcbiAgfVxuXG4gIC8vIFNpIGMnZXN0IHVuIGRlbWktam91ciwgYWp1c3RlciBsZSBjYWxjdWxcbiAgaWYgKGlzSGFsZkRheSAmJiB3b3JraW5nRGF5cyA+IDApIHtcbiAgICAvLyBTaSBjJ2VzdCBsZSBtw6ptZSBqb3VyIChkw6lidXQgPSBmaW4pLCBjJ2VzdCAwLjUgam91clxuICAgIGlmIChpc1NhbWVEYXkoc3RhcnQsIGVuZCkpIHtcbiAgICAgIHdvcmtpbmdEYXlzID0gMC41O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQb3VyIGxlcyBww6lyaW9kZXMgZGUgcGx1c2lldXJzIGpvdXJzLCBvbiBwZXV0IGFqdXN0ZXIgc2Vsb24gbGUgdHlwZSBkZSBkZW1pLWpvdXJcbiAgICAgIC8vIFBhciBkw6lmYXV0LCBvbiBnYXJkZSBsZSBjYWxjdWwgbm9ybWFsIGNhciBsZXMgZGVtaS1qb3VycyBzb250IGfDqW7DqXJhbGVtZW50XG4gICAgICAvLyBhcHBsaXF1w6lzIGF1IHByZW1pZXIgb3UgZGVybmllciBqb3VyIHNlbG9uIGxlIGNvbnRleHRlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtpbmdEYXlzO1xufVxuXG4vKipcbiAqIFbDqXJpZmllIHNpIHVuZSBkYXRlIGVzdCB1biBqb3VyIGbDqXJpw6lcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSG9saWRheShkYXRlOiBEYXRlLCBob2xpZGF5czogUHVibGljSG9saWRheVtdKTogYm9vbGVhbiB7XG4gIHJldHVybiBob2xpZGF5cy5zb21lKGhvbGlkYXkgPT4ge1xuICAgIGNvbnN0IGhvbGlkYXlEYXRlID0gbmV3IERhdGUoaG9saWRheS5kYXRlKTtcbiAgICAvLyBDb21wYXJlciBsZXMgZGF0ZXMgZW4gZm9ybWF0IFlZWVktTU0tREQgcG91ciDDqXZpdGVyIGxlcyBwcm9ibMOobWVzIGRlIHRpbWV6b25lXG4gICAgY29uc3QgZGF0ZVN0ciA9IGRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xuICAgIGNvbnN0IGhvbGlkYXlTdHIgPSBob2xpZGF5RGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gICAgcmV0dXJuIGRhdGVTdHIgPT09IGhvbGlkYXlTdHI7XG4gIH0pO1xufVxuXG4vKipcbiAqIE9idGllbnQgbGVzIGpvdXJzIGbDqXJpw6lzIHBvdXIgdW5lIGFubsOpZSBkb25uw6llXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIb2xpZGF5c0ZvclllYXIoeWVhcjogbnVtYmVyKTogUHVibGljSG9saWRheVtdIHtcbiAgaWYgKHllYXIgPT09IDIwMjQpIHJldHVybiBGUkVOQ0hfSE9MSURBWVNfMjAyNDtcbiAgaWYgKHllYXIgPT09IDIwMjUpIHJldHVybiBGUkVOQ0hfSE9MSURBWVNfMjAyNTtcbiAgXG4gIC8vIFBvdXIgbGVzIGF1dHJlcyBhbm7DqWVzLCBvbiBwZXV0IMOpdGVuZHJlIG91IHV0aWxpc2VyIHVuZSBBUElcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIENhbGN1bGUgbGUgc29sZGUgZGUgY29uZ8OpcyBwb3VyIGNoYXF1ZSB0eXBlIGVuIGluY2x1YW50IGxlcyByZWxpcXVhdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUxlYXZlQmFsYW5jZXMoXG4gIGxlYXZlczogTGVhdmVFbnRyeVtdLFxuICBxdW90YXM6IHsgdHlwZTogTGVhdmVUeXBlOyB5ZWFybHlRdW90YTogbnVtYmVyIH1bXSxcbiAgY2FycnlvdmVyczogQ2FycnlvdmVyTGVhdmVbXSA9IFtdLFxuICB5ZWFyOiBudW1iZXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKClcbik6IExlYXZlQmFsYW5jZVtdIHtcbiAgY29uc3QgYmFsYW5jZXM6IExlYXZlQmFsYW5jZVtdID0gW107XG5cbiAgcXVvdGFzLmZvckVhY2gocXVvdGEgPT4ge1xuICAgIGNvbnN0IHllYXJMZWF2ZXMgPSBsZWF2ZXMuZmlsdGVyKGxlYXZlID0+IFxuICAgICAgbGVhdmUudHlwZSA9PT0gcXVvdGEudHlwZSAmJiBcbiAgICAgIG5ldyBEYXRlKGxlYXZlLnN0YXJ0RGF0ZSkuZ2V0RnVsbFllYXIoKSA9PT0geWVhclxuICAgICk7XG5cbiAgICBjb25zdCB1c2VkID0geWVhckxlYXZlcy5yZWR1Y2UoKHRvdGFsLCBsZWF2ZSkgPT4gdG90YWwgKyBsZWF2ZS53b3JraW5nRGF5cywgMCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsZXIgbGVzIHJlbGlxdWF0cyBwb3VyIGNlIHR5cGUgZGUgY29uZ8OpXG4gICAgY29uc3QgY2FycnlvdmVyRGF5cyA9IGNhcnJ5b3ZlcnNcbiAgICAgIC5maWx0ZXIoY2FycnlvdmVyID0+IGNhcnJ5b3Zlci50eXBlID09PSBxdW90YS50eXBlKVxuICAgICAgLnJlZHVjZSgodG90YWwsIGNhcnJ5b3ZlcikgPT4gdG90YWwgKyBjYXJyeW92ZXIuZGF5cywgMCk7XG4gICAgXG4gICAgLy8gTGUgdG90YWwgaW5jbHV0IGxlIHF1b3RhIGFubnVlbCArIGxlcyByZWxpcXVhdHNcbiAgICBjb25zdCB0b3RhbFdpdGhDYXJyeW92ZXIgPSBxdW90YS55ZWFybHlRdW90YSArIGNhcnJ5b3ZlckRheXM7XG4gICAgY29uc3QgcmVtYWluaW5nID0gTWF0aC5tYXgoMCwgdG90YWxXaXRoQ2FycnlvdmVyIC0gdXNlZCk7XG5cbiAgICBiYWxhbmNlcy5wdXNoKHtcbiAgICAgIHR5cGU6IHF1b3RhLnR5cGUsXG4gICAgICB0b3RhbDogdG90YWxXaXRoQ2FycnlvdmVyLFxuICAgICAgdXNlZCxcbiAgICAgIHJlbWFpbmluZyxcbiAgICAgIGNhcnJ5b3ZlcjogY2FycnlvdmVyRGF5cyxcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJhbGFuY2VzO1xufVxuXG4vKipcbiAqIENhbGN1bGUgbGVzIHJlbGlxdWF0cyBkaXNwb25pYmxlcyBwb3VyIHVuZSBhbm7DqWUgZG9ubsOpZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXZhaWxhYmxlQ2FycnlvdmVyKFxuICBjYXJyeW92ZXJzOiBDYXJyeW92ZXJMZWF2ZVtdLFxuICB5ZWFyOiBudW1iZXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKClcbik6IFJlY29yZDxMZWF2ZVR5cGUsIG51bWJlcj4ge1xuICBjb25zdCBhdmFpbGFibGU6IFJlY29yZDxMZWF2ZVR5cGUsIG51bWJlcj4gPSB7XG4gICAgY3A6IDAsIHJ0dDogMCwgY2V0OiAwLCBzaWNrOiAwXG4gIH07XG5cbiAgY2FycnlvdmVycy5mb3JFYWNoKGNhcnJ5b3ZlciA9PiB7XG4gICAgYXZhaWxhYmxlW2NhcnJ5b3Zlci50eXBlXSArPSBjYXJyeW92ZXIuZGF5cztcbiAgfSk7XG5cbiAgcmV0dXJuIGF2YWlsYWJsZTtcbn1cblxuLyoqXG4gKiBHw6luw6hyZSB1biByw6lzdW3DqSBkZXMgcmVsaXF1YXRzIHBhciBhbm7DqWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ2FycnlvdmVyU3VtbWFyeShjYXJyeW92ZXJzOiBDYXJyeW92ZXJMZWF2ZVtdKToge1xuICBieVllYXI6IFJlY29yZDxudW1iZXIsIENhcnJ5b3ZlckxlYXZlW10+O1xuICBieVR5cGU6IFJlY29yZDxMZWF2ZVR5cGUsIENhcnJ5b3ZlckxlYXZlW10+O1xuICB0b3RhbEJ5VHlwZTogUmVjb3JkPExlYXZlVHlwZSwgbnVtYmVyPjtcbn0ge1xuICBjb25zdCBieVllYXI6IFJlY29yZDxudW1iZXIsIENhcnJ5b3ZlckxlYXZlW10+ID0ge307XG4gIGNvbnN0IGJ5VHlwZTogUmVjb3JkPExlYXZlVHlwZSwgQ2FycnlvdmVyTGVhdmVbXT4gPSB7XG4gICAgY3A6IFtdLCBydHQ6IFtdLCBjZXQ6IFtdLCBzaWNrOiBbXVxuICB9O1xuICBjb25zdCB0b3RhbEJ5VHlwZTogUmVjb3JkPExlYXZlVHlwZSwgbnVtYmVyPiA9IHtcbiAgICBjcDogMCwgcnR0OiAwLCBjZXQ6IDAsIHNpY2s6IDBcbiAgfTtcblxuICBjYXJyeW92ZXJzLmZvckVhY2goY2FycnlvdmVyID0+IHtcbiAgICAvLyBQYXIgYW5uw6llXG4gICAgaWYgKCFieVllYXJbY2FycnlvdmVyLnllYXJdKSB7XG4gICAgICBieVllYXJbY2FycnlvdmVyLnllYXJdID0gW107XG4gICAgfVxuICAgIGJ5WWVhcltjYXJyeW92ZXIueWVhcl0ucHVzaChjYXJyeW92ZXIpO1xuXG4gICAgLy8gUGFyIHR5cGVcbiAgICBieVR5cGVbY2FycnlvdmVyLnR5cGVdLnB1c2goY2FycnlvdmVyKTtcbiAgICB0b3RhbEJ5VHlwZVtjYXJyeW92ZXIudHlwZV0gKz0gY2FycnlvdmVyLmRheXM7XG4gIH0pO1xuXG4gIHJldHVybiB7IGJ5WWVhciwgYnlUeXBlLCB0b3RhbEJ5VHlwZSB9O1xufVxuXG4vKipcbiAqIFZhbGlkZSBzaSBsZXMgUlRUIHBldXZlbnQgw6p0cmUgcHJpcyBwb3VyIHVuIG1vaXMgZG9ubsOpXG4gKiBMZXMgUlRUIHMnYWNjdW11bGVudCDDoCBsYSBmaW4gZHUgbW9pcywgZG9uYyBvbiBuZSBwZXV0IGxlcyBwcmVuZHJlXG4gKiBxdWUgc2kgbGUgbW9pcyBjb3JyZXNwb25kYW50IGVzdCBwYXNzw6lcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhblRha2VSVFRGb3JNb250aChcbiAgdGFyZ2V0TW9udGg6IG51bWJlciwgLy8gMS0xMlxuICB0YXJnZXRZZWFyOiBudW1iZXIsXG4gIGN1cnJlbnREYXRlOiBEYXRlID0gbmV3IERhdGUoKVxuKTogeyBjYW5UYWtlOiBib29sZWFuOyByZWFzb24/OiBzdHJpbmc7IGF2YWlsYWJsZURheXM6IG51bWJlciB9IHtcbiAgY29uc3QgY3VycmVudE1vbnRoID0gY3VycmVudERhdGUuZ2V0TW9udGgoKSArIDE7IC8vIDEtMTJcbiAgY29uc3QgY3VycmVudFllYXIgPSBjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpO1xuICBcbiAgLy8gU2kgb24gZXN0IGRhbnMgdW5lIGFubsOpZSBmdXR1cmUsIG9uIG5lIHBldXQgcGFzIGVuY29yZSBwcmVuZHJlIGxlcyBSVFRcbiAgaWYgKHRhcmdldFllYXIgPiBjdXJyZW50WWVhcikge1xuICAgIHJldHVybiB7XG4gICAgICBjYW5UYWtlOiBmYWxzZSxcbiAgICAgIHJlYXNvbjogYExlcyBSVFQgZGUgJHt0YXJnZXRZZWFyfSBuZSBzb250IHBhcyBlbmNvcmUgZGlzcG9uaWJsZXNgLFxuICAgICAgYXZhaWxhYmxlRGF5czogMFxuICAgIH07XG4gIH1cbiAgXG4gIC8vIFNpIG9uIGVzdCBkYW5zIHVuZSBhbm7DqWUgcGFzc8OpZSwgb24gcGV1dCBwcmVuZHJlIGxlcyBSVFRcbiAgaWYgKHRhcmdldFllYXIgPCBjdXJyZW50WWVhcikge1xuICAgIHJldHVybiB7XG4gICAgICBjYW5UYWtlOiB0cnVlLFxuICAgICAgYXZhaWxhYmxlRGF5czogMiAvLyAyIFJUVCBwYXIgbW9pc1xuICAgIH07XG4gIH1cbiAgXG4gIC8vIE3Dqm1lIGFubsOpZSA6IHbDqXJpZmllciBzaSBsZSBtb2lzIGVzdCBwYXNzw6lcbiAgaWYgKHRhcmdldE1vbnRoIDwgY3VycmVudE1vbnRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhblRha2U6IHRydWUsXG4gICAgICBhdmFpbGFibGVEYXlzOiAyXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0YXJnZXRNb250aCA9PT0gY3VycmVudE1vbnRoKSB7XG4gICAgLy8gUG91ciBsZSBtb2lzIGVuIGNvdXJzLCBvbiBwZXV0IHByZW5kcmUgbGVzIFJUVCBkw6hzIGxlIGTDqWJ1dCBkdSBtb2lzXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhblRha2U6IHRydWUsXG4gICAgICBhdmFpbGFibGVEYXlzOiAyXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBNb2lzIGZ1dHVyXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhblRha2U6IGZhbHNlLFxuICAgICAgcmVhc29uOiBgTGVzIFJUVCBkZSBjZSBtb2lzIG5lIHNvbnQgcGFzIGVuY29yZSBkaXNwb25pYmxlc2AsXG4gICAgICBhdmFpbGFibGVEYXlzOiAwXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGUgbGUgbm9tYnJlIHRvdGFsIGRlIFJUVCBkaXNwb25pYmxlcyBwb3VyIHVuZSBww6lyaW9kZSBkb25uw6llXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVBdmFpbGFibGVSVFRGb3JQZXJpb2QoXG4gIHN0YXJ0RGF0ZTogRGF0ZSxcbiAgZW5kRGF0ZTogRGF0ZSxcbiAgY3VycmVudERhdGU6IERhdGUgPSBuZXcgRGF0ZSgpXG4pOiB7IHRvdGFsQXZhaWxhYmxlOiBudW1iZXI7IGRldGFpbHM6IEFycmF5PHsgbW9udGg6IG51bWJlcjsgeWVhcjogbnVtYmVyOyBhdmFpbGFibGU6IG51bWJlcjsgY2FuVGFrZTogYm9vbGVhbiB9PiB9IHtcbiAgY29uc3QgZGV0YWlsczogQXJyYXk8eyBtb250aDogbnVtYmVyOyB5ZWFyOiBudW1iZXI7IGF2YWlsYWJsZTogbnVtYmVyOyBjYW5UYWtlOiBib29sZWFuIH0+ID0gW107XG4gIGxldCB0b3RhbEF2YWlsYWJsZSA9IDA7XG4gIFxuICBjb25zdCBjdXJyZW50ID0gbmV3IERhdGUoc3RhcnREYXRlKTtcbiAgXG4gIHdoaWxlIChjdXJyZW50IDw9IGVuZERhdGUpIHtcbiAgICBjb25zdCBtb250aCA9IGN1cnJlbnQuZ2V0TW9udGgoKSArIDE7XG4gICAgY29uc3QgeWVhciA9IGN1cnJlbnQuZ2V0RnVsbFllYXIoKTtcbiAgICBcbiAgICBjb25zdCB2YWxpZGF0aW9uID0gY2FuVGFrZVJUVEZvck1vbnRoKG1vbnRoLCB5ZWFyLCBjdXJyZW50RGF0ZSk7XG4gICAgXG4gICAgZGV0YWlscy5wdXNoKHtcbiAgICAgIG1vbnRoLFxuICAgICAgeWVhcixcbiAgICAgIGF2YWlsYWJsZTogdmFsaWRhdGlvbi5hdmFpbGFibGVEYXlzLFxuICAgICAgY2FuVGFrZTogdmFsaWRhdGlvbi5jYW5UYWtlXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKHZhbGlkYXRpb24uY2FuVGFrZSkge1xuICAgICAgdG90YWxBdmFpbGFibGUgKz0gdmFsaWRhdGlvbi5hdmFpbGFibGVEYXlzO1xuICAgIH1cbiAgICBcbiAgICAvLyBQYXNzZXIgYXUgbW9pcyBzdWl2YW50XG4gICAgY3VycmVudC5zZXRNb250aChjdXJyZW50LmdldE1vbnRoKCkgKyAxKTtcbiAgfVxuICBcbiAgcmV0dXJuIHsgdG90YWxBdmFpbGFibGUsIGRldGFpbHMgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxlIGxlIG5vbWJyZSB0b3RhbCBkZSBSVFQgZGlzcG9uaWJsZXMgYWN0dWVsbGVtZW50XG4gKiAoZGVwdWlzIGxlIGTDqWJ1dCBkZSBsJ2FubsOpZSBqdXNxdSfDoCBtYWludGVuYW50KVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQ3VycmVudEF2YWlsYWJsZVJUVChcbiAgY3VycmVudERhdGU6IERhdGUgPSBuZXcgRGF0ZSgpLFxuICB5ZWFyOiBudW1iZXIgPSBjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpXG4pOiB7IHRvdGFsQXZhaWxhYmxlOiBudW1iZXI7IGRldGFpbHM6IEFycmF5PHsgbW9udGg6IG51bWJlcjsgYXZhaWxhYmxlOiBudW1iZXI7IGNhblRha2U6IGJvb2xlYW47IHJlYXNvbj86IHN0cmluZyB9PiB9IHtcbiAgY29uc3QgZGV0YWlsczogQXJyYXk8eyBtb250aDogbnVtYmVyOyBhdmFpbGFibGU6IG51bWJlcjsgY2FuVGFrZTogYm9vbGVhbjsgcmVhc29uPzogc3RyaW5nIH0+ID0gW107XG4gIGxldCB0b3RhbEF2YWlsYWJsZSA9IDA7XG4gIFxuICAvLyBQYXJjb3VyaXIgdG91cyBsZXMgbW9pcyBkZSBsJ2FubsOpZSBqdXNxdSdhdSBtb2lzIGFjdHVlbFxuICBmb3IgKGxldCBtb250aCA9IDE7IG1vbnRoIDw9IDEyOyBtb250aCsrKSB7XG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IGNhblRha2VSVFRGb3JNb250aChtb250aCwgeWVhciwgY3VycmVudERhdGUpO1xuICAgIFxuICAgIGRldGFpbHMucHVzaCh7XG4gICAgICBtb250aCxcbiAgICAgIGF2YWlsYWJsZTogdmFsaWRhdGlvbi5hdmFpbGFibGVEYXlzLFxuICAgICAgY2FuVGFrZTogdmFsaWRhdGlvbi5jYW5UYWtlLFxuICAgICAgcmVhc29uOiB2YWxpZGF0aW9uLnJlYXNvblxuICAgIH0pO1xuICAgIFxuICAgIGlmICh2YWxpZGF0aW9uLmNhblRha2UpIHtcbiAgICAgIHRvdGFsQXZhaWxhYmxlICs9IHZhbGlkYXRpb24uYXZhaWxhYmxlRGF5cztcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiB7IHRvdGFsQXZhaWxhYmxlLCBkZXRhaWxzIH07XG59XG5cbi8vIE5vdXZlbGxlIGZvbmN0aW9uIHBvdXIgY2FsY3VsZXIgbGVzIGRvbm7DqWVzIHPDqXBhcsOpZXMgcGFyIHR5cGUgKHLDqWVsIHZzIHByw6l2aXNpb24pXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTW9udGhseUxlYXZlU3VtbWFyeVNlcGFyYXRlZChcbiAgbGVhdmVzOiBMZWF2ZUVudHJ5W10sXG4gIHF1b3RhczogeyB0eXBlOiBMZWF2ZVR5cGU7IHllYXJseVF1b3RhOiBudW1iZXIgfVtdLFxuICBjYXJyeW92ZXJzOiBDYXJyeW92ZXJMZWF2ZVtdID0gW10sXG4gIHllYXI6IG51bWJlciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKVxuKToge1xuICBtb250aHM6IEFycmF5PHtcbiAgICBtb250aDogbnVtYmVyO1xuICAgIG1vbnRoTmFtZTogc3RyaW5nO1xuICAgIHJ0dDoge1xuICAgICAgcmVhbDogeyB0YWtlbjogbnVtYmVyOyBjdW11bDogbnVtYmVyOyByZW1haW5pbmc6IG51bWJlciB9O1xuICAgICAgZm9yZWNhc3Q6IHsgdGFrZW46IG51bWJlcjsgY3VtdWw6IG51bWJlcjsgcmVtYWluaW5nOiBudW1iZXIgfTtcbiAgICB9O1xuICAgIGNwOiB7XG4gICAgICByZWFsOiB7IHRha2VuOiBudW1iZXI7IGN1bXVsOiBudW1iZXI7IHJlbWFpbmluZzogbnVtYmVyIH07XG4gICAgICBmb3JlY2FzdDogeyB0YWtlbjogbnVtYmVyOyBjdW11bDogbnVtYmVyOyByZW1haW5pbmc6IG51bWJlciB9O1xuICAgIH07XG4gIH0+O1xuICB5ZWFybHlUb3RhbHM6IHtcbiAgICBydHQ6IHsgcmVhbDogbnVtYmVyOyBmb3JlY2FzdDogbnVtYmVyOyB0b3RhbDogbnVtYmVyIH07XG4gICAgY3A6IHsgcmVhbDogbnVtYmVyOyBmb3JlY2FzdDogbnVtYmVyOyB0b3RhbDogbnVtYmVyIH07XG4gIH07XG59IHtcbiAgY29uc3QgbW9udGhzID0gW107XG4gIGNvbnN0IG1vbnRoTmFtZXMgPSBbXG4gICAgJ0phbnZpZXInLCAnRsOpdnJpZXInLCAnTWFycycsICdBdnJpbCcsICdNYWknLCAnSnVpbicsXG4gICAgJ0p1aWxsZXQnLCAnQW/Du3QnLCAnU2VwdGVtYnJlJywgJ09jdG9icmUnLCAnTm92ZW1icmUnLCAnRMOpY2VtYnJlJ1xuICBdO1xuXG4gIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcbiAgY29uc3QgY3VycmVudE1vbnRoID0gY3VycmVudERhdGUuZ2V0TW9udGgoKSArIDE7IC8vIDEtMTJcbiAgY29uc3QgY3VycmVudFllYXIgPSBjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gIC8vIFLDqWN1cMOpcmVyIGxlcyBxdW90YXNcbiAgY29uc3QgcnR0UXVvdGEgPSBxdW90YXMuZmluZChxID0+IHEudHlwZSA9PT0gJ3J0dCcpPy55ZWFybHlRdW90YSB8fCAyMztcbiAgY29uc3QgY3BRdW90YSA9IHF1b3Rhcy5maW5kKHEgPT4gcS50eXBlID09PSAnY3AnKT8ueWVhcmx5UXVvdGEgfHwgMjU7XG4gIGNvbnN0IGNldFF1b3RhID0gcXVvdGFzLmZpbmQocSA9PiBxLnR5cGUgPT09ICdjZXQnKT8ueWVhcmx5UXVvdGEgfHwgNTtcbiAgY29uc3QgdG90YWxDUENFVFF1b3RhID0gY3BRdW90YSArIGNldFF1b3RhO1xuXG4gIC8vIFLDqWN1cMOpcmVyIGxlcyByZWxpcXVhdHNcbiAgY29uc3QgcnR0Q2FycnlvdmVyID0gY2FycnlvdmVycy5maW5kKGMgPT4gYy50eXBlID09PSAncnR0Jyk/LmRheXMgfHwgMDtcbiAgY29uc3QgY3BDYXJyeW92ZXIgPSBjYXJyeW92ZXJzLmZpbmQoYyA9PiBjLnR5cGUgPT09ICdjcCcpPy5kYXlzIHx8IDA7XG4gIGNvbnN0IGNldENhcnJ5b3ZlciA9IGNhcnJ5b3ZlcnMuZmluZChjID0+IGMudHlwZSA9PT0gJ2NldCcpPy5kYXlzIHx8IDA7XG4gIGNvbnN0IHRvdGFsQ1BDRVRDYXJyeW92ZXIgPSBjcENhcnJ5b3ZlciArIGNldENhcnJ5b3ZlcjtcblxuICBsZXQgcnR0Q3VtdWxSZWFsID0gMDtcbiAgbGV0IHJ0dEN1bXVsRm9yZWNhc3QgPSAwO1xuICBsZXQgY3BDdW11bFJlYWwgPSAwO1xuICBsZXQgY3BDdW11bEZvcmVjYXN0ID0gMDtcblxuICBmb3IgKGxldCBtb250aCA9IDE7IG1vbnRoIDw9IDEyOyBtb250aCsrKSB7XG4gICAgLy8gRmlsdHJlciBsZXMgY29uZ8OpcyBwb3VyIGNlIG1vaXMgZXQgY2V0dGUgYW5uw6llXG4gICAgY29uc3QgbW9udGhMZWF2ZXMgPSBsZWF2ZXMuZmlsdGVyKGxlYXZlID0+IHtcbiAgICAgIGNvbnN0IGxlYXZlRGF0ZSA9IG5ldyBEYXRlKGxlYXZlLnN0YXJ0RGF0ZSk7XG4gICAgICByZXR1cm4gbGVhdmVEYXRlLmdldEZ1bGxZZWFyKCkgPT09IHllYXIgJiYgbGVhdmVEYXRlLmdldE1vbnRoKCkgPT09IG1vbnRoIC0gMTtcbiAgICB9KTtcblxuICAgIC8vIFPDqXBhcmVyIGxlcyBjb25nw6lzIHLDqWVscyBldCBsZXMgcHLDqXZpc2lvbnNcbiAgICAvLyBTaSBsZSBtb2lzIGVzdCBwYXNzw6ksIGxlcyBwcsOpdmlzaW9ucyBkZXZpZW5uZW50IHLDqWVsbGVzXG4gICAgY29uc3QgaXNNb250aFBhc3NlZCA9IHllYXIgPCBjdXJyZW50WWVhciB8fCAoeWVhciA9PT0gY3VycmVudFllYXIgJiYgbW9udGggPCBjdXJyZW50TW9udGgpO1xuICAgIGNvbnN0IGlzQ3VycmVudE1vbnRoID0geWVhciA9PT0gY3VycmVudFllYXIgJiYgbW9udGggPT09IGN1cnJlbnRNb250aDtcbiAgICBcbiAgICAvLyBDb25nw6lzIHLDqWVscyA6IHRvdXMgbGVzIGNvbmfDqXMgbm9uIG1hcnF1w6lzIGNvbW1lIHByw6l2aXNpb24gT1UgbGVzIHByw6l2aXNpb25zIGRlcyBtb2lzIHBhc3PDqXNcbiAgICBjb25zdCBydHRSZWFsID0gbW9udGhMZWF2ZXNcbiAgICAgIC5maWx0ZXIobGVhdmUgPT4gbGVhdmUudHlwZSA9PT0gJ3J0dCcgJiYgKCFsZWF2ZS5pc0ZvcmVjYXN0IHx8IGlzTW9udGhQYXNzZWQpKVxuICAgICAgLnJlZHVjZSgoc3VtLCBsZWF2ZSkgPT4gc3VtICsgbGVhdmUud29ya2luZ0RheXMsIDApO1xuXG4gICAgY29uc3QgY3BSZWFsID0gbW9udGhMZWF2ZXNcbiAgICAgIC5maWx0ZXIobGVhdmUgPT4gbGVhdmUudHlwZSA9PT0gJ2NwJyAmJiAoIWxlYXZlLmlzRm9yZWNhc3QgfHwgaXNNb250aFBhc3NlZCkpXG4gICAgICAucmVkdWNlKChzdW0sIGxlYXZlKSA9PiBzdW0gKyBsZWF2ZS53b3JraW5nRGF5cywgMCk7XG5cbiAgICAvLyBQb3VyIGxlcyBwcsOpdmlzaW9ucywgY29tcHRlciBsZXMgY29uZ8OpcyBtYXJxdcOpcyBjb21tZSBwcsOpdmlzaW9uIGRlcyBtb2lzIGZ1dHVyc1xuICAgIC8vIEVUIGxlcyBjb25nw6lzIG5vbiBtYXJxdcOpcyBjb21tZSBwcsOpdmlzaW9uIGRlcyBtb2lzIGZ1dHVycyAocG91ciBzaW11bGF0aW9uKVxuICAgIGNvbnN0IHJ0dEZvcmVjYXN0ID0gbW9udGhMZWF2ZXNcbiAgICAgIC5maWx0ZXIobGVhdmUgPT4gbGVhdmUudHlwZSA9PT0gJ3J0dCcgJiYgKGxlYXZlLmlzRm9yZWNhc3QgfHwgKCFpc01vbnRoUGFzc2VkICYmICFpc0N1cnJlbnRNb250aCkpKVxuICAgICAgLnJlZHVjZSgoc3VtLCBsZWF2ZSkgPT4gc3VtICsgbGVhdmUud29ya2luZ0RheXMsIDApO1xuXG4gICAgY29uc3QgY3BGb3JlY2FzdCA9IG1vbnRoTGVhdmVzXG4gICAgICAuZmlsdGVyKGxlYXZlID0+IGxlYXZlLnR5cGUgPT09ICdjcCcgJiYgKGxlYXZlLmlzRm9yZWNhc3QgfHwgKCFpc01vbnRoUGFzc2VkICYmICFpc0N1cnJlbnRNb250aCkpKVxuICAgICAgLnJlZHVjZSgoc3VtLCBsZWF2ZSkgPT4gc3VtICsgbGVhdmUud29ya2luZ0RheXMsIDApO1xuXG4gICAgLy8gQ2FsY3VsZXIgbGVzIGN1bXVsc1xuICAgIHJ0dEN1bXVsUmVhbCArPSBydHRSZWFsO1xuICAgIHJ0dEN1bXVsRm9yZWNhc3QgKz0gcnR0Rm9yZWNhc3Q7XG4gICAgY3BDdW11bFJlYWwgKz0gY3BSZWFsO1xuICAgIGNwQ3VtdWxGb3JlY2FzdCArPSBjcEZvcmVjYXN0O1xuXG4gICAgLy8gQ2FsY3VsZXIgbGVzIHNvbGRlcyByZXN0YW50cyAoY3VtdWxzIGludmVyc8OpcylcbiAgICBjb25zdCBydHRSZW1haW5pbmdSZWFsID0gTWF0aC5tYXgoMCwgcnR0UXVvdGEgKyBydHRDYXJyeW92ZXIgLSBydHRDdW11bFJlYWwpO1xuICAgIGNvbnN0IHJ0dFJlbWFpbmluZ0ZvcmVjYXN0ID0gTWF0aC5tYXgoMCwgcnR0UXVvdGEgKyBydHRDYXJyeW92ZXIgLSBydHRDdW11bFJlYWwgLSBydHRDdW11bEZvcmVjYXN0KTtcbiAgICBjb25zdCBjcFJlbWFpbmluZ1JlYWwgPSBNYXRoLm1heCgwLCB0b3RhbENQQ0VUUXVvdGEgKyB0b3RhbENQQ0VUQ2FycnlvdmVyIC0gY3BDdW11bFJlYWwpO1xuICAgIGNvbnN0IGNwUmVtYWluaW5nRm9yZWNhc3QgPSBNYXRoLm1heCgwLCB0b3RhbENQQ0VUUXVvdGEgKyB0b3RhbENQQ0VUQ2FycnlvdmVyIC0gY3BDdW11bFJlYWwgLSBjcEN1bXVsRm9yZWNhc3QpO1xuXG4gICAgbW9udGhzLnB1c2goe1xuICAgICAgbW9udGgsXG4gICAgICBtb250aE5hbWU6IG1vbnRoTmFtZXNbbW9udGggLSAxXSxcbiAgICAgIHJ0dDoge1xuICAgICAgICByZWFsOiB7IHRha2VuOiBydHRSZWFsLCBjdW11bDogcnR0Q3VtdWxSZWFsLCByZW1haW5pbmc6IHJ0dFJlbWFpbmluZ1JlYWwgfSxcbiAgICAgICAgZm9yZWNhc3Q6IHsgdGFrZW46IHJ0dEZvcmVjYXN0LCBjdW11bDogcnR0Q3VtdWxGb3JlY2FzdCwgcmVtYWluaW5nOiBydHRSZW1haW5pbmdGb3JlY2FzdCB9XG4gICAgICB9LFxuICAgICAgY3A6IHtcbiAgICAgICAgcmVhbDogeyB0YWtlbjogY3BSZWFsLCBjdW11bDogY3BDdW11bFJlYWwsIHJlbWFpbmluZzogY3BSZW1haW5pbmdSZWFsIH0sXG4gICAgICAgIGZvcmVjYXN0OiB7IHRha2VuOiBjcEZvcmVjYXN0LCBjdW11bDogY3BDdW11bEZvcmVjYXN0LCByZW1haW5pbmc6IGNwUmVtYWluaW5nRm9yZWNhc3QgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtb250aHMsXG4gICAgeWVhcmx5VG90YWxzOiB7XG4gICAgICBydHQ6IHsgcmVhbDogcnR0Q3VtdWxSZWFsLCBmb3JlY2FzdDogcnR0Q3VtdWxGb3JlY2FzdCwgdG90YWw6IHJ0dEN1bXVsUmVhbCArIHJ0dEN1bXVsRm9yZWNhc3QgfSxcbiAgICAgIGNwOiB7IHJlYWw6IGNwQ3VtdWxSZWFsLCBmb3JlY2FzdDogY3BDdW11bEZvcmVjYXN0LCB0b3RhbDogY3BDdW11bFJlYWwgKyBjcEN1bXVsRm9yZWNhc3QgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gRm9uY3Rpb24gdXRpbGl0YWlyZSBwb3VyIHbDqXJpZmllciBzaSBkZXV4IGNvbmfDqXMgY29ycmVzcG9uZGVudCDDoCBsYSBtw6ptZSBww6lyaW9kZVxuZnVuY3Rpb24gaXNTYW1lUGVyaW9kKGZvcmVjYXN0OiBMZWF2ZUVudHJ5LCByZWFsOiBMZWF2ZUVudHJ5KTogYm9vbGVhbiB7XG4gIC8vIFNpIGMnZXN0IHVuIHNldWwgam91ciwgdsOpcmlmaWVyIGxhIGRhdGUgZXhhY3RlXG4gIGlmIChmb3JlY2FzdC53b3JraW5nRGF5cyA9PT0gMSAmJiByZWFsLndvcmtpbmdEYXlzID09PSAxKSB7XG4gICAgcmV0dXJuIGZvcmVjYXN0LnN0YXJ0RGF0ZSA9PT0gcmVhbC5zdGFydERhdGU7XG4gIH1cbiAgXG4gIC8vIFNpIGMnZXN0IHVuZSBww6lyaW9kZSwgdsOpcmlmaWVyIHNpIGxlcyBkYXRlcyBzZSBjaGV2YXVjaGVudFxuICBjb25zdCBmb3JlY2FzdFN0YXJ0ID0gbmV3IERhdGUoZm9yZWNhc3Quc3RhcnREYXRlKTtcbiAgY29uc3QgZm9yZWNhc3RFbmQgPSBuZXcgRGF0ZShmb3JlY2FzdC5lbmREYXRlKTtcbiAgY29uc3QgcmVhbFN0YXJ0ID0gbmV3IERhdGUocmVhbC5zdGFydERhdGUpO1xuICBjb25zdCByZWFsRW5kID0gbmV3IERhdGUocmVhbC5lbmREYXRlKTtcbiAgXG4gIC8vIFbDqXJpZmllciBzaSBsZXMgcMOpcmlvZGVzIHNlIGNoZXZhdWNoZW50XG4gIHJldHVybiBmb3JlY2FzdFN0YXJ0IDw9IHJlYWxFbmQgJiYgcmVhbFN0YXJ0IDw9IGZvcmVjYXN0RW5kO1xufVxuXG5cbi8qKlxuICogR8OpbsOocmUgbGVzIGRvbm7DqWVzIGR1IGNhbGVuZHJpZXIgcG91ciB1biBtb2lzIGRvbm7DqVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDYWxlbmRhckRheXMoXG4gIHllYXI6IG51bWJlcixcbiAgbW9udGg6IG51bWJlcixcbiAgbGVhdmVzOiBMZWF2ZUVudHJ5W10sXG4gIGhvbGlkYXlzOiBQdWJsaWNIb2xpZGF5W11cbik6IENhbGVuZGFyRGF5W10ge1xuICBjb25zdCBkYXlzOiBDYWxlbmRhckRheVtdID0gW107XG4gIGNvbnN0IHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgMSk7XG4gIGNvbnN0IGVuZERhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMCk7XG5cbiAgbGV0IGN1cnJlbnREYXRlID0gc3RhcnREYXRlO1xuICB3aGlsZSAoY3VycmVudERhdGUgPD0gZW5kRGF0ZSkge1xuICAgIGNvbnN0IGRhdGVTdHIgPSBmb3JtYXQoY3VycmVudERhdGUsICd5eXl5LU1NLWRkJyk7XG4gICAgY29uc3QgbGVhdmUgPSBsZWF2ZXMuZmluZChsID0+IHtcbiAgICAgIGNvbnN0IGxlYXZlU3RhcnQgPSBuZXcgRGF0ZShsLnN0YXJ0RGF0ZSk7XG4gICAgICBjb25zdCBsZWF2ZUVuZCA9IG5ldyBEYXRlKGwuZW5kRGF0ZSk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc1NhbWVEYXkoY3VycmVudERhdGUsIGxlYXZlU3RhcnQpIHx8XG4gICAgICAgIGlzU2FtZURheShjdXJyZW50RGF0ZSwgbGVhdmVFbmQpIHx8XG4gICAgICAgIChpc0FmdGVyKGN1cnJlbnREYXRlLCBsZWF2ZVN0YXJ0KSAmJiBpc0JlZm9yZShjdXJyZW50RGF0ZSwgbGVhdmVFbmQpKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGhvbGlkYXkgPSBob2xpZGF5cy5maW5kKGggPT4ge1xuICAgICAgY29uc3QgaG9saWRheURhdGUgPSBuZXcgRGF0ZShoLmRhdGUpO1xuICAgICAgcmV0dXJuIGlzU2FtZURheShjdXJyZW50RGF0ZSwgaG9saWRheURhdGUpO1xuICAgIH0pO1xuXG4gICAgZGF5cy5wdXNoKHtcbiAgICAgIGRhdGU6IGRhdGVTdHIsXG4gICAgICBpc0xlYXZlOiAhIWxlYXZlLFxuICAgICAgbGVhdmVUeXBlOiBsZWF2ZT8udHlwZSxcbiAgICAgIGlzV2Vla2VuZDogaXNXZWVrZW5kKGN1cnJlbnREYXRlKSxcbiAgICAgIGlzSG9saWRheTogISFob2xpZGF5LFxuICAgICAgaG9saWRheU5hbWU6IGhvbGlkYXk/Lm5hbWUsXG4gICAgfSk7XG5cbiAgICBjdXJyZW50RGF0ZSA9IGFkZERheXMoY3VycmVudERhdGUsIDEpO1xuICB9XG5cbiAgcmV0dXJuIGRheXM7XG59XG5cbi8qKlxuICogRm9ybWF0ZSB1bmUgZGF0ZSBwb3VyIGwnYWZmaWNoYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlKGRhdGU6IHN0cmluZyB8IERhdGUsIGZvcm1hdFN0cjogc3RyaW5nID0gJ2RkL01NL3l5eXknKTogc3RyaW5nIHtcbiAgY29uc3QgZGF0ZU9iaiA9IHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJyA/IG5ldyBEYXRlKGRhdGUpIDogZGF0ZTtcbiAgXG4gIC8vIFZhbGlkYXRlIHRoZSBkYXRlXG4gIGlmIChpc05hTihkYXRlT2JqLmdldFRpbWUoKSkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGUgZm9yIGZvcm1hdHRpbmc6JywgZGF0ZSk7XG4gICAgcmV0dXJuICdEYXRlIGludmFsaWRlJztcbiAgfVxuICBcbiAgcmV0dXJuIGZvcm1hdChkYXRlT2JqLCBmb3JtYXRTdHIsIHsgbG9jYWxlOiBmciB9KTtcbn1cblxuLyoqXG4gKiBPYnRpZW50IGxlIG5vbSBkdSB0eXBlIGRlIGNvbmfDqVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVhdmVUeXBlTGFiZWwodHlwZTogTGVhdmVUeXBlKTogc3RyaW5nIHtcbiAgcmV0dXJuIExFQVZFX1RZUEVTW3R5cGVdLmxhYmVsO1xufVxuXG4vKipcbiAqIE9idGllbnQgbGEgY291bGV1ciBkdSB0eXBlIGRlIGNvbmfDqVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVhdmVUeXBlQ29sb3IodHlwZTogTGVhdmVUeXBlKTogc3RyaW5nIHtcbiAgcmV0dXJuIExFQVZFX1RZUEVTW3R5cGVdLmNvbG9yO1xufVxuXG4vKipcbiAqIE9idGllbnQgbCdpY8O0bmUgZHUgdHlwZSBkZSBjb25nw6lcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExlYXZlVHlwZUljb24odHlwZTogTGVhdmVUeXBlKTogc3RyaW5nIHtcbiAgcmV0dXJuIExFQVZFX1RZUEVTW3R5cGVdLmljb247XG59XG5cbi8qKlxuICogVmFsaWRlIHVuZSBww6lyaW9kZSBkZSBjb25nw6lzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUxlYXZlUGVyaW9kKFxuICBzdGFydERhdGU6IHN0cmluZyxcbiAgZW5kRGF0ZTogc3RyaW5nLFxuICBleGlzdGluZ0xlYXZlczogTGVhdmVFbnRyeVtdLFxuICBleGNsdWRlSWQ/OiBzdHJpbmdcbik6IHsgaXNWYWxpZDogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfSB7XG4gIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoc3RhcnREYXRlKTtcbiAgY29uc3QgZW5kID0gbmV3IERhdGUoZW5kRGF0ZSk7XG5cbiAgaWYgKGlzQWZ0ZXIoc3RhcnQsIGVuZCkpIHtcbiAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6ICdMYSBkYXRlIGRlIGTDqWJ1dCBkb2l0IMOqdHJlIGFudMOpcmlldXJlIMOgIGxhIGRhdGUgZGUgZmluJyB9O1xuICB9XG5cbiAgLy8gVsOpcmlmaWVyIGxlcyBjaGV2YXVjaGVtZW50cyBhdmVjIGxlcyBjb25nw6lzIGV4aXN0YW50c1xuICBjb25zdCBvdmVybGFwcGluZyA9IGV4aXN0aW5nTGVhdmVzXG4gICAgLmZpbHRlcihsZWF2ZSA9PiBsZWF2ZS5pZCAhPT0gZXhjbHVkZUlkKVxuICAgIC5zb21lKGxlYXZlID0+IHtcbiAgICAgIGNvbnN0IGxlYXZlU3RhcnQgPSBuZXcgRGF0ZShsZWF2ZS5zdGFydERhdGUpO1xuICAgICAgY29uc3QgbGVhdmVFbmQgPSBuZXcgRGF0ZShsZWF2ZS5lbmREYXRlKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGlzQWZ0ZXIoc3RhcnQsIGxlYXZlU3RhcnQpICYmIGlzQmVmb3JlKHN0YXJ0LCBsZWF2ZUVuZCkpIHx8XG4gICAgICAgIChpc0FmdGVyKGVuZCwgbGVhdmVTdGFydCkgJiYgaXNCZWZvcmUoZW5kLCBsZWF2ZUVuZCkpIHx8XG4gICAgICAgIChpc0JlZm9yZShzdGFydCwgbGVhdmVTdGFydCkgJiYgaXNBZnRlcihlbmQsIGxlYXZlRW5kKSkgfHxcbiAgICAgICAgaXNTYW1lRGF5KHN0YXJ0LCBsZWF2ZVN0YXJ0KSB8fFxuICAgICAgICBpc1NhbWVEYXkoZW5kLCBsZWF2ZUVuZClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgaWYgKG92ZXJsYXBwaW5nKSB7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiAnQ2V0dGUgcMOpcmlvZGUgY2hldmF1Y2hlIHVuIGNvbmfDqSBleGlzdGFudCcgfTtcbiAgfVxuXG4gIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxlIGxlcyBzdGF0aXN0aXF1ZXMgZGVzIGNvbmfDqXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUxlYXZlU3RhdHMobGVhdmVzOiBMZWF2ZUVudHJ5W10sIHllYXI6IG51bWJlcik6IHtcbiAgdG90YWxEYXlzOiBudW1iZXI7XG4gIGJ5VHlwZTogUmVjb3JkPExlYXZlVHlwZSwgbnVtYmVyPjtcbiAgYnlNb250aDogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbn0ge1xuICBjb25zdCB5ZWFyTGVhdmVzID0gbGVhdmVzLmZpbHRlcihsZWF2ZSA9PiBcbiAgICBuZXcgRGF0ZShsZWF2ZS5zdGFydERhdGUpLmdldEZ1bGxZZWFyKCkgPT09IHllYXJcbiAgKTtcblxuICBjb25zdCB0b3RhbERheXMgPSB5ZWFyTGVhdmVzLnJlZHVjZSgodG90YWwsIGxlYXZlKSA9PiB0b3RhbCArIGxlYXZlLndvcmtpbmdEYXlzLCAwKTtcbiAgXG4gIGNvbnN0IGJ5VHlwZTogUmVjb3JkPExlYXZlVHlwZSwgbnVtYmVyPiA9IHtcbiAgICBjcDogMCwgcnR0OiAwLCBjZXQ6IDAsIHNpY2s6IDBcbiAgfTtcbiAgXG4gIGNvbnN0IGJ5TW9udGg6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcblxuICB5ZWFyTGVhdmVzLmZvckVhY2gobGVhdmUgPT4ge1xuICAgIGJ5VHlwZVtsZWF2ZS50eXBlXSArPSBsZWF2ZS53b3JraW5nRGF5cztcbiAgICBcbiAgICBjb25zdCBsZWF2ZVN0YXJ0ID0gbmV3IERhdGUobGVhdmUuc3RhcnREYXRlKTtcbiAgICBjb25zdCBtb250aCA9IGZvcm1hdChsZWF2ZVN0YXJ0LCAneXl5eS1NTScpO1xuICAgIGJ5TW9udGhbbW9udGhdID0gKGJ5TW9udGhbbW9udGhdIHx8IDApICsgbGVhdmUud29ya2luZ0RheXM7XG4gIH0pO1xuXG4gIHJldHVybiB7IHRvdGFsRGF5cywgYnlUeXBlLCBieU1vbnRoIH07XG59XG5cbi8qKlxuICogQ29udmVydGl0IHVuZSBkYXRlIGR1IGZvcm1hdCBmcmFuw6dhaXMgKEREL01NL1lZWVkpIHZlcnMgbGUgZm9ybWF0IElTTyAoWVlZWS1NTS1ERClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyZW5jaERhdGVUb0lTTyhmcmVuY2hEYXRlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIWZyZW5jaERhdGUgfHwgZnJlbmNoRGF0ZS5sZW5ndGggIT09IDEwKSByZXR1cm4gJydcbiAgXG4gIGNvbnN0IHBhcnRzID0gZnJlbmNoRGF0ZS5zcGxpdCgnLycpXG4gIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHJldHVybiAnJ1xuICBcbiAgY29uc3QgW2RheSwgbW9udGgsIHllYXJdID0gcGFydHNcbiAgcmV0dXJuIGAke3llYXJ9LSR7bW9udGgucGFkU3RhcnQoMiwgJzAnKX0tJHtkYXkucGFkU3RhcnQoMiwgJzAnKX1gXG59XG5cbi8qKlxuICogQ29udmVydGl0IHVuZSBkYXRlIGR1IGZvcm1hdCBJU08gKFlZWVktTU0tREQpIHZlcnMgbGUgZm9ybWF0IGZyYW7Dp2FpcyAoREQvTU0vWVlZWSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzb0RhdGVUb0ZyZW5jaChpc29EYXRlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIWlzb0RhdGUgfHwgaXNvRGF0ZS5sZW5ndGggIT09IDEwKSByZXR1cm4gJydcbiAgXG4gIGNvbnN0IHBhcnRzID0gaXNvRGF0ZS5zcGxpdCgnLScpXG4gIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHJldHVybiAnJ1xuICBcbiAgY29uc3QgW3llYXIsIG1vbnRoLCBkYXldID0gcGFydHNcbiAgcmV0dXJuIGAke2RheX0vJHttb250aH0vJHt5ZWFyfWBcbn1cblxuLyoqXG4gKiBWYWxpZGUgdW5lIGRhdGUgYXUgZm9ybWF0IGZyYW7Dp2FpcyAoREQvTU0vWVlZWSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRGcmVuY2hEYXRlKGZyZW5jaERhdGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoIWZyZW5jaERhdGUgfHwgZnJlbmNoRGF0ZS5sZW5ndGggIT09IDEwKSByZXR1cm4gZmFsc2VcbiAgXG4gIGNvbnN0IHBhcnRzID0gZnJlbmNoRGF0ZS5zcGxpdCgnLycpXG4gIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHJldHVybiBmYWxzZVxuICBcbiAgY29uc3QgW2RheSwgbW9udGgsIHllYXJdID0gcGFydHNcbiAgY29uc3QgaXNvRGF0ZSA9IGAke3llYXJ9LSR7bW9udGgucGFkU3RhcnQoMiwgJzAnKX0tJHtkYXkucGFkU3RhcnQoMiwgJzAnKX1gXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShpc29EYXRlKVxuICBcbiAgcmV0dXJuICFpc05hTihkYXRlLmdldFRpbWUoKSkgJiYgXG4gICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCkgPj0gMjAyMCAmJiBcbiAgICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSA8PSAyMDMwXG59XG4iXSwibmFtZXMiOlsiYWRkRGF5cyIsImZvcm1hdCIsImlzQWZ0ZXIiLCJpc0JlZm9yZSIsImlzU2FtZURheSIsImlzV2Vla2VuZCIsImZyIiwiTEVBVkVfVFlQRVMiLCJjcCIsImxhYmVsIiwiY29sb3IiLCJpY29uIiwicnR0IiwiY2V0Iiwic2ljayIsIkZSRU5DSF9IT0xJREFZU18yMDI0IiwiaWQiLCJkYXRlIiwibmFtZSIsImNvdW50cnkiLCJGUkVOQ0hfSE9MSURBWVNfMjAyNSIsImNhbGN1bGF0ZVdvcmtpbmdEYXlzIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImhvbGlkYXlzIiwiaXNIYWxmRGF5IiwiaGFsZkRheVR5cGUiLCJzdGFydCIsIkRhdGUiLCJlbmQiLCJpc05hTiIsImdldFRpbWUiLCJjb25zb2xlIiwiZXJyb3IiLCJ3b3JraW5nRGF5cyIsImN1cnJlbnREYXRlIiwiaXNIb2xpZGF5Iiwic29tZSIsImhvbGlkYXkiLCJob2xpZGF5RGF0ZSIsImRhdGVTdHIiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwiaG9saWRheVN0ciIsImdldEhvbGlkYXlzRm9yWWVhciIsInllYXIiLCJjYWxjdWxhdGVMZWF2ZUJhbGFuY2VzIiwibGVhdmVzIiwicXVvdGFzIiwiY2FycnlvdmVycyIsImdldEZ1bGxZZWFyIiwiYmFsYW5jZXMiLCJmb3JFYWNoIiwicXVvdGEiLCJ5ZWFyTGVhdmVzIiwiZmlsdGVyIiwibGVhdmUiLCJ0eXBlIiwidXNlZCIsInJlZHVjZSIsInRvdGFsIiwiY2FycnlvdmVyRGF5cyIsImNhcnJ5b3ZlciIsImRheXMiLCJ0b3RhbFdpdGhDYXJyeW92ZXIiLCJ5ZWFybHlRdW90YSIsInJlbWFpbmluZyIsIk1hdGgiLCJtYXgiLCJwdXNoIiwiY2FsY3VsYXRlQXZhaWxhYmxlQ2FycnlvdmVyIiwiYXZhaWxhYmxlIiwiZ2VuZXJhdGVDYXJyeW92ZXJTdW1tYXJ5IiwiYnlZZWFyIiwiYnlUeXBlIiwidG90YWxCeVR5cGUiLCJjYW5UYWtlUlRURm9yTW9udGgiLCJ0YXJnZXRNb250aCIsInRhcmdldFllYXIiLCJjdXJyZW50TW9udGgiLCJnZXRNb250aCIsImN1cnJlbnRZZWFyIiwiY2FuVGFrZSIsInJlYXNvbiIsImF2YWlsYWJsZURheXMiLCJjYWxjdWxhdGVBdmFpbGFibGVSVFRGb3JQZXJpb2QiLCJkZXRhaWxzIiwidG90YWxBdmFpbGFibGUiLCJjdXJyZW50IiwibW9udGgiLCJ2YWxpZGF0aW9uIiwic2V0TW9udGgiLCJjYWxjdWxhdGVDdXJyZW50QXZhaWxhYmxlUlRUIiwiY2FsY3VsYXRlTW9udGhseUxlYXZlU3VtbWFyeVNlcGFyYXRlZCIsIm1vbnRocyIsIm1vbnRoTmFtZXMiLCJydHRRdW90YSIsImZpbmQiLCJxIiwiY3BRdW90YSIsImNldFF1b3RhIiwidG90YWxDUENFVFF1b3RhIiwicnR0Q2FycnlvdmVyIiwiYyIsImNwQ2FycnlvdmVyIiwiY2V0Q2FycnlvdmVyIiwidG90YWxDUENFVENhcnJ5b3ZlciIsInJ0dEN1bXVsUmVhbCIsInJ0dEN1bXVsRm9yZWNhc3QiLCJjcEN1bXVsUmVhbCIsImNwQ3VtdWxGb3JlY2FzdCIsIm1vbnRoTGVhdmVzIiwibGVhdmVEYXRlIiwiaXNNb250aFBhc3NlZCIsImlzQ3VycmVudE1vbnRoIiwicnR0UmVhbCIsImlzRm9yZWNhc3QiLCJzdW0iLCJjcFJlYWwiLCJydHRGb3JlY2FzdCIsImNwRm9yZWNhc3QiLCJydHRSZW1haW5pbmdSZWFsIiwicnR0UmVtYWluaW5nRm9yZWNhc3QiLCJjcFJlbWFpbmluZ1JlYWwiLCJjcFJlbWFpbmluZ0ZvcmVjYXN0IiwibW9udGhOYW1lIiwicmVhbCIsInRha2VuIiwiY3VtdWwiLCJmb3JlY2FzdCIsInllYXJseVRvdGFscyIsImlzU2FtZVBlcmlvZCIsImZvcmVjYXN0U3RhcnQiLCJmb3JlY2FzdEVuZCIsInJlYWxTdGFydCIsInJlYWxFbmQiLCJnZW5lcmF0ZUNhbGVuZGFyRGF5cyIsImwiLCJsZWF2ZVN0YXJ0IiwibGVhdmVFbmQiLCJoIiwiaXNMZWF2ZSIsImxlYXZlVHlwZSIsImhvbGlkYXlOYW1lIiwiZm9ybWF0RGF0ZSIsImZvcm1hdFN0ciIsImRhdGVPYmoiLCJsb2NhbGUiLCJnZXRMZWF2ZVR5cGVMYWJlbCIsImdldExlYXZlVHlwZUNvbG9yIiwiZ2V0TGVhdmVUeXBlSWNvbiIsInZhbGlkYXRlTGVhdmVQZXJpb2QiLCJleGlzdGluZ0xlYXZlcyIsImV4Y2x1ZGVJZCIsImlzVmFsaWQiLCJvdmVybGFwcGluZyIsImNhbGN1bGF0ZUxlYXZlU3RhdHMiLCJ0b3RhbERheXMiLCJieU1vbnRoIiwiZnJlbmNoRGF0ZVRvSVNPIiwiZnJlbmNoRGF0ZSIsImxlbmd0aCIsInBhcnRzIiwiZGF5IiwicGFkU3RhcnQiLCJpc29EYXRlVG9GcmVuY2giLCJpc29EYXRlIiwiaXNWYWxpZEZyZW5jaERhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/leaveUtils.ts\n"));

/***/ })

});